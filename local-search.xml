<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>笔记/微服务/springcloudAlibaba 简介 </title>
    <link href="/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/springcloudAlibaba%20%E7%AE%80%E4%BB%8B%20/"/>
    <url>/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/springcloudAlibaba%20%E7%AE%80%E4%BB%8B%20/</url>
    
    <content type="html"><![CDATA[<h3 id="为什么会出现SpringCloudAlibaba？？"><a href="#为什么会出现SpringCloudAlibaba？？" class="headerlink" title="为什么会出现SpringCloudAlibaba？？"></a>为什么会出现SpringCloudAlibaba？？</h3><p>Springcloud Netflix 项目进入了维护模式。</p><p>进入维护模式就意味着：<strong style="color:red">springcloudNetflix将很长一段时间不会开发新的组件</strong></p><h3 id="SpringCloudAlibaba是什么"><a href="#SpringCloudAlibaba是什么" class="headerlink" title="SpringCloudAlibaba是什么"></a>SpringCloudAlibaba是什么</h3><p>​        他是由一些阿里巴巴的开源组件和云产品组成的。这个项目整合了Spring 框架，其优秀的设计模式和抽象理念，给使用阿里巴巴产品的java开发者带来使用SpringBoot和SpringCloud的更多便利。</p><h3 id="能干嘛"><a href="#能干嘛" class="headerlink" title="能干嘛"></a>能干嘛</h3><ul><li><strong style="color:red">服务限流降级</strong>：默认支持 Servlet ,Feign,RestTemplate,Dubbo和RocketMq 限流降级功能的接入，可以在运行时通过控制台实时修改限流降级规则，还支持查询限流降级Metrics监控。</li><li><strong style="color:red">服务注册与发现：</strong>适配SpringCloud服务注册与发现标准，默认集成了Ribbon的支持</li><li><strong style="color:red">分布式配置管理：</strong>支持分布式系统中的外部化配置，配置更改时自动刷新</li><li><strong style="color:red">消息驱动能力：</strong>基于SpringCloudStream为微服务应用构建消息驱动能力。</li><li><strong style="color:red">阿里云对象储存：</strong>阿里云提供的海量，安全，低成本，高可靠的云存储服务。支持在任何应用，任何时间，任何地点存储和访问任意类型的数据。</li><li><strong style="color:red">分布式任务调度：</strong>提供秒级，精准，高可靠，高可用的定时任务（基于Cron表达式）调度服务。同时提供分布式的任务执行模型，如网格任务。网格任务支持海量子任务均匀分配到所有Worker(schedulerx-client)上执行</li></ul><h3 id="文档中心"><a href="#文档中心" class="headerlink" title="文档中心"></a><a href="https://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md" target="_blank" rel="noopener">文档中心</a></h3><h3 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h3><ul><li><p>Sentinel： 把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</p></li><li><p>Nacos: 一个更易于构建云原生应用的动态服务发现，配置管理和服务管理平台。</p></li><li><p>RocketMQ:一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可高的消息发布与订阅服务。</p></li><li><p>Dubbo：Apache Dubbo™是一款高性能javaRpc框架。</p></li><li><p>Seata:阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。</p></li><li><p>Alibaba Cloud ACM:一款在分布式架构环境中对应用配置进行集中管理和推送的应用配置中心产品。</p></li><li><p>Ailt:ba Clud OSs:阿里云对象存榼服努(ObjctStoage sarice，简称OSS)，是阿里云提供的海虽、安全、低成本、高可常的云存情报务。您可以在任何应用、任回时间、任何地点存情和防问任身类型的数据.</p></li><li><p>Aibaba Cloud Schedulerk:阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准、高可靠、高可用的定时(基于Cron表达式)任务调度服务。</p></li><li><p>Alibaba Cloud SMS:覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。   </p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记/微服务/9-2-2springcloudAblibabaSeata 原理简介</title>
    <link href="/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/9-2-2springcloudAblibabaSeata%20%E5%8E%9F%E7%90%86%E7%AE%80%E4%BB%8B/"/>
    <url>/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/9-2-2springcloudAblibabaSeata%20%E5%8E%9F%E7%90%86%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a>Seata</h3><p>2019年1月份蚂蚁金服和阿里巴巴共同开源的分布式事务解决方案</p><p>Simple Extensible Autonomous Transaction Architecture,简单可扩展自治事务框架</p><h3 id="TC-TM-RM-三大组件"><a href="#TC-TM-RM-三大组件" class="headerlink" title="TC/TM/RM 三大组件"></a>TC/TM/RM 三大组件</h3><p><img src="D:%5C%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE%5C%E5%8D%9A%E5%AE%A2%5Cimage-20201118215007974.png" srcset="/img/loading.gif" alt="image-20201118215007974"></p><p><strong>分布式事务执行流程</strong></p><ol><li>TM开启分布式事务(TM向TC注册全局事务记录)</li><li>换业务场景，编排数据库，服务等事务内资源（RM向TC汇报资源准备状态)</li><li>TM结束分布式事务，事务—阶段结束(TM通知TC提交/回滚分布式事务)</li><li>TC汇总事务信息，决定分布式事务是提交还是回滚</li><li>TC通知所有RM提交/回滚资源，事务二阶段结束。</li></ol><h4 id="AT模式如何做到对业务的无侵入"><a href="#AT模式如何做到对业务的无侵入" class="headerlink" title="AT模式如何做到对业务的无侵入"></a><strong>AT模式如何做到对业务的无侵入</strong></h4><h4 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h4><ul><li>基于支持本地ACID事务的关系型数据库。</li><li>Java应用，通过JDBC访问数据库。</li></ul><h4 id="整体机制"><a href="#整体机制" class="headerlink" title="整体机制"></a>整体机制</h4><ul><li>一阶段:业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源。</li><li>二阶段:<br>   提交异步化，非常快速地完成。<pre><code>回滚通过—阶段的回滚日志进行反向补偿。</code></pre></li></ul><h4 id="一阶段加载"><a href="#一阶段加载" class="headerlink" title="一阶段加载"></a>一阶段加载</h4><p><strong>在一阶段，Seata会拦截 “业务SQL”</strong></p><ol><li>解析SQL语义，找到“业务SQL”要更新的业务数据，在业务数据被更新前，将其保存成“before image”</li><li>执行“业务SQL” 更新业务数据，在业务数据更新之后</li><li>其保存成“agter Image”,最后生成行锁</li></ol><p>以上操作全部在一个数据库事务内完成，这样保证了一阶段操作的原子性</p><h4 id="二阶段提交"><a href="#二阶段提交" class="headerlink" title="二阶段提交"></a>二阶段提交</h4><p>二阶段如是顺利提交的话，因为“业务SQL”在一阶段已经提交至数据库，所以Seata框架只需将一阶段保存的快照数据和行锁删掉，完成数据清理即可。</p><h4 id="二阶段回滚"><a href="#二阶段回滚" class="headerlink" title="二阶段回滚"></a>二阶段回滚</h4><p>二阶段如果是回滚的话，Seata就需要回滚一阶段已经执行的“业务SQL”,还原业务数据。</p><p><strong style="color:blue">回滚方式便是用“before image” 还原业务数据；但在还原前要首先校验脏写，对比“数据库当前业务数据”和“after image” ,如果两份数据完全一致就说明没有脏写，可以还原业务数据，如果不一致就说明有脏写，出现脏写就需要转人工处理。</strong></p><p><img src="D:%5C%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE%5C%E5%8D%9A%E5%AE%A2%5Cimage-20201118221254332.png" srcset="/img/loading.gif" alt="image-20201118221254332"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记/微服务/9-2-1springcloudAblibabaSeata分布式事务使用</title>
    <link href="/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/9-2-1springcloudAblibabaSeata%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/9-2-1springcloudAblibabaSeata%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="seata配置安装"><a href="#seata配置安装" class="headerlink" title="seata配置安装"></a>seata配置安装</h3><p><a href="http://seata.io/zh-cn/" target="_blank" rel="noopener">官网</a></p><p><a href="http://seata.io/zh-cn/blog/download.html" target="_blank" rel="noopener">下载地址</a></p><p>我下载0.9的版本。</p><p>下载解压</p><ol><li><p>打开conf目录下的file.conf文件</p></li><li><p>修改service 模块下的</p>  <pre><code class="hljs java">vgroup_mapping.my_test_tx_group = "xxx" # 自定义很重要，相当于服务端的服务名</code></pre></li><li><p>修改store 模块下的mode ##切换成数据库模式</p>  <pre><code class="hljs java">mode = "db" #修改db 模块把数据库信息改成你自己的要 0.9版本不支持mysql8.0及以上</code></pre></li><li><p>然后建一个数据库，把当前目录下的db_store.sql 执行即可</p></li><li><p>打开当前目录下的registry.conf</p></li><li><p>把registry 目录下的type 改成nacos</p>  <pre><code class="hljs java">type = <span class="hljs-string">"nacos"</span></code></pre></li><li><p>然后启动nacos 再启动seata  （启动seata解压目录下的bin目录下）</p></li></ol><h3 id="测试项目启动"><a href="#测试项目启动" class="headerlink" title="测试项目启动"></a>测试项目启动</h3><p><strong>订单、库存、账户业务数据库准备</strong></p><p>说明：</p><p>这里我们会创建三个服务，一个订单服务，一个库存服务，一个账户服务。</p><p>当用户下单时，会在订单服务中创建一个订单，然后通过远程调用库存服务来扣减下单商品的库存，再通过远程调用账户服务来扣减用户账户里面的余额，</p><p>最后在订单服务中修改订单状态为已完成。<br>该操作跨越三个数据库，有两次远程调用，很明显会有分布式事务问题。</p><p>ps:<strong style="color:red">下订单–&gt;扣库存–&gt;减账户（余额)</strong></p><p><strong>创建数据库</strong></p><ul><li>创建订单数据库 <strong style="color:red">seata_order</strong></li><li>创建库存数据库<strong style="color:red">seata_storage</strong></li><li>创建账户信息数据库<strong style="color:red">seata_account</strong></li></ul><p><strong>对应的数据库建表</strong></p><p> <strong style="color:blue">eata_order</strong></p><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t_order(    <span class="hljs-string">`id`</span> <span class="hljs-built_in">BIGINT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT PRIMARY <span class="hljs-keyword">KEY</span>,    <span class="hljs-string">`user_id`</span> <span class="hljs-built_in">BIGINT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'用户id'</span>,    <span class="hljs-string">`product_id`</span> <span class="hljs-built_in">BIGINT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'产品id'</span>,    <span class="hljs-string">`count`</span> <span class="hljs-built_in">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'数量'</span>,    <span class="hljs-string">`money`</span> <span class="hljs-built_in">DECIMAL</span>(<span class="hljs-number">11</span>,<span class="hljs-number">0</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'金额'</span>,    <span class="hljs-string">`status`</span> <span class="hljs-built_in">INT</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'订单状态：0：创建中; 1：已完结'</span>) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">INNODB</span> AUTO_INCREMENT=<span class="hljs-number">7</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8; <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_order;</code></pre><p><strong style="color:blue">seata_storage</strong></p><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t_storage(    <span class="hljs-string">`id`</span> <span class="hljs-built_in">BIGINT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT PRIMARY <span class="hljs-keyword">KEY</span>,    <span class="hljs-string">`product_id`</span> <span class="hljs-built_in">BIGINT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'产品id'</span>,   <span class="hljs-string">`'total`</span> <span class="hljs-built_in">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'总库存'</span>,    <span class="hljs-string">`used`</span> <span class="hljs-built_in">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'已用库存'</span>,    <span class="hljs-string">`residue`</span> <span class="hljs-built_in">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'剩余库存'</span>) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">INNODB</span> AUTO_INCREMENT=<span class="hljs-number">2</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8; <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> seata_storage.t_storage(<span class="hljs-string">`id`</span>,<span class="hljs-string">`product_id`</span>,<span class="hljs-string">`total`</span>,<span class="hljs-string">`used`</span>,<span class="hljs-string">`residue`</span>)<span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'1'</span>,<span class="hljs-string">'1'</span>,<span class="hljs-string">'100'</span>,<span class="hljs-string">'0'</span>,<span class="hljs-string">'100'</span>);  <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_storage;</code></pre><p> <strong style="color:blue">seata_account</strong></p><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t_account(    <span class="hljs-string">`id`</span> <span class="hljs-built_in">BIGINT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT PRIMARY <span class="hljs-keyword">KEY</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'id'</span>,    <span class="hljs-string">`user_id`</span> <span class="hljs-built_in">BIGINT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'用户id'</span>,    <span class="hljs-string">`total`</span> <span class="hljs-built_in">DECIMAL</span>(<span class="hljs-number">10</span>,<span class="hljs-number">0</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'总额度'</span>,    <span class="hljs-string">`used`</span> <span class="hljs-built_in">DECIMAL</span>(<span class="hljs-number">10</span>,<span class="hljs-number">0</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'已用余额'</span>,    <span class="hljs-string">`residue`</span> <span class="hljs-built_in">DECIMAL</span>(<span class="hljs-number">10</span>,<span class="hljs-number">0</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">'0'</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'剩余可用额度'</span>) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">INNODB</span> AUTO_INCREMENT=<span class="hljs-number">2</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8; <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> seata_account.t_account(<span class="hljs-string">`id`</span>,<span class="hljs-string">`user_id`</span>,<span class="hljs-string">`total`</span>,<span class="hljs-string">`used`</span>,<span class="hljs-string">`residue`</span>) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'1'</span>,<span class="hljs-string">'1'</span>,<span class="hljs-string">'1000'</span>,<span class="hljs-string">'0'</span>,<span class="hljs-string">'1000'</span>)<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_account;</code></pre><p>然后三个数据库分别创建回滚日志表</p><pre><code class="hljs java">-- the table to store seata xid data-- <span class="hljs-number">0.7</span><span class="hljs-number">.0</span>+ add context-- you must to init <span class="hljs-keyword">this</span> sql <span class="hljs-keyword">for</span> you business databese. the seata server not need it.-- 此脚本必须初始化在你当前的业务数据库中，用于AT 模式XID记录。与server端无关（注：业务数据库）-- 注意此处<span class="hljs-number">0.3</span><span class="hljs-number">.0</span>+ 增加唯一索引 ux_undo_logdrop table `undo_log`;CREATE TABLE `undo_log` (  `id` bigint(<span class="hljs-number">20</span>) NOT NULL AUTO_INCREMENT,  `branch_id` bigint(<span class="hljs-number">20</span>) NOT NULL,  `xid` varchar(<span class="hljs-number">100</span>) NOT NULL,  `context` varchar(<span class="hljs-number">128</span>) NOT NULL,  `rollback_info` longblob NOT NULL,  `log_status` <span class="hljs-keyword">int</span>(<span class="hljs-number">11</span>) NOT NULL,  `log_created` datetime NOT NULL,  `log_modified` datetime NOT NULL,  `ext` varchar(<span class="hljs-number">100</span>) DEFAULT NULL,  <span class="hljs-function">PRIMARY <span class="hljs-title">KEY</span> <span class="hljs-params">(`id`)</span>,</span><span class="hljs-function">  UNIQUE KEY `ux_undo_log` <span class="hljs-params">(`xid`,`branch_id`)</span></span><span class="hljs-function">) ENGINE</span>=InnoDB AUTO_INCREMENT=<span class="hljs-number">1</span> DEFAULT CHARSET=utf8;</code></pre><h3 id="订单、库存、账户业务微服务准备"><a href="#订单、库存、账户业务微服务准备" class="headerlink" title="订单、库存、账户业务微服务准备"></a>订单、库存、账户业务微服务准备</h3><h4 id="订单"><a href="#订单" class="headerlink" title="订单"></a><strong>订单</strong></h4><p><strong>pom</strong></p><pre><code class="hljs java"> &lt;dependencies&gt;    &lt;!--nacos--&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;!--seata--&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-alibaba-seata&lt;/artifactId&gt;        &lt;exclusions&gt;            &lt;exclusion&gt;                &lt;artifactId&gt;seata-all&lt;/artifactId&gt;                &lt;groupId&gt;io.seata&lt;/groupId&gt;            &lt;/exclusion&gt;        &lt;/exclusions&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;io.seata&lt;/groupId&gt;        &lt;artifactId&gt;seata-all&lt;/artifactId&gt;        &lt;version&gt;0.9.0&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--feign--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;!--web-actuator--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;!--mysql-druid--&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;5.1.37&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;        &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;        &lt;version&gt;1.1.10&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;        &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;        &lt;version&gt;2.0.0&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;        &lt;artifactId&gt;lombok&lt;/artifactId&gt;        &lt;optional&gt;true&lt;/optional&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>YML</p><pre><code class="hljs ya">server:  port: 2001 spring:  application:    name: seata-order-service  cloud:    alibaba:      seata:        #自定义事务组名称需要与seata-server中的对应        tx-service-group: xxx    nacos:      discovery:        server-addr: localhost:8848  datasource:    driver-class-name: com.mysql.jdbc.Driver    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;seata_order    username: root    password: 1111111 feign:  hystrix:    enabled: false logging:  level:    io:      seata: info mybatis:  mapperLocations: classpath:mapper&#x2F;*.xml</code></pre><p><strong>file.conf</strong></p><pre><code class="hljs java">transport &#123;  # tcp udt unix-domain-socket  type = <span class="hljs-string">"TCP"</span>  #NIO NATIVE  server = <span class="hljs-string">"NIO"</span>  #enable heartbeat  heartbeat = <span class="hljs-keyword">true</span>  #thread factory for netty  thread-factory &#123;    boss-thread-prefix = <span class="hljs-string">"NettyBoss"</span>    worker-thread-prefix = <span class="hljs-string">"NettyServerNIOWorker"</span>    server-executor-thread-prefix = <span class="hljs-string">"NettyServerBizHandler"</span>    share-boss-worker = <span class="hljs-keyword">false</span>    client-selector-thread-prefix = <span class="hljs-string">"NettyClientSelector"</span>    client-selector-thread-size = <span class="hljs-number">1</span>    client-worker-thread-prefix = <span class="hljs-string">"NettyClientWorkerThread"</span>    # netty boss thread size,will not be used for UDT    boss-thread-size = <span class="hljs-number">1</span>    #auto default pin or 8    worker-thread-size = <span class="hljs-number">8</span>  &#125;  shutdown &#123;    # when destroy server, wait seconds    wait = <span class="hljs-number">3</span>  &#125;  serialization = <span class="hljs-string">"seata"</span>  compressor = <span class="hljs-string">"none"</span>&#125; service &#123;   vgroup_mapping.fsp_tx_group = <span class="hljs-string">"default"</span>    <span class="hljs-keyword">default</span>.grouplist = <span class="hljs-string">"127.0.0.1:8091"</span>  enableDegrade = <span class="hljs-keyword">false</span>  disable = <span class="hljs-keyword">false</span>  max.commit.retry.timeout = <span class="hljs-string">"-1"</span>  max.rollback.retry.timeout = <span class="hljs-string">"-1"</span>  disableGlobalTransaction = <span class="hljs-keyword">false</span>&#125;  client &#123;  async.commit.buffer.limit = <span class="hljs-number">10000</span>  lock &#123;    retry.internal = <span class="hljs-number">10</span>    retry.times = <span class="hljs-number">30</span>  &#125;  report.retry.count = <span class="hljs-number">5</span>  tm.commit.retry.count = <span class="hljs-number">1</span>  tm.rollback.retry.count = <span class="hljs-number">1</span>&#125; ## transaction log storestore &#123;  ## store mode: file、db  mode = <span class="hljs-string">"db"</span>   ## file store  file &#123;    dir = <span class="hljs-string">"sessionStore"</span>     # branch session size , if exceeded first try compress lockkey, still exceeded throws exceptions    max-branch-session-size = <span class="hljs-number">16384</span>    # globe session size , if exceeded throws exceptions    max-global-session-size = <span class="hljs-number">512</span>    # file buffer size , if exceeded allocate new buffer    file-write-buffer-cache-size = <span class="hljs-number">16384</span>    # when recover batch read size    session.reload.read_size = <span class="hljs-number">100</span>    # async, sync    flush-disk-mode = async  &#125;   ## database store  db &#123;    ## the implement of javax.sql.DataSource, such as DruidDataSource(druid)/BasicDataSource(dbcp) etc.    datasource = <span class="hljs-string">"dbcp"</span>    ## mysql/oracle/h2/oceanbase etc.    db-type = <span class="hljs-string">"mysql"</span>    driver-<span class="hljs-class"><span class="hljs-keyword">class</span>-<span class="hljs-title">name</span> </span>= <span class="hljs-string">"com.mysql.jdbc.Driver"</span>    url = <span class="hljs-string">"jdbc:mysql://127.0.0.1:3306/seata"</span>    user = <span class="hljs-string">"root"</span>    password = <span class="hljs-string">"123456"</span>    min-conn = <span class="hljs-number">1</span>    max-conn = <span class="hljs-number">3</span>    global.table = <span class="hljs-string">"global_table"</span>    branch.table = <span class="hljs-string">"branch_table"</span>    lock-table = <span class="hljs-string">"lock_table"</span>    query-limit = <span class="hljs-number">100</span>  &#125;&#125;lock &#123;  ## the lock store mode: local、remote  mode = <span class="hljs-string">"remote"</span>   local &#123;    ## store locks in user's database  &#125;   remote &#123;    ## store locks in the seata's server  &#125;&#125;recovery &#123;  #schedule committing retry period in milliseconds  committing-retry-period = <span class="hljs-number">1000</span>  #schedule asyn committing retry period in milliseconds  asyn-committing-retry-period = <span class="hljs-number">1000</span>  #schedule rollbacking retry period in milliseconds  rollbacking-retry-period = <span class="hljs-number">1000</span>  #schedule timeout retry period in milliseconds  timeout-retry-period = <span class="hljs-number">1000</span>&#125; transaction &#123;  undo.data.validation = <span class="hljs-keyword">true</span>  undo.log.serialization = <span class="hljs-string">"jackson"</span>  undo.log.save.days = <span class="hljs-number">7</span>  #schedule delete expired undo_log in milliseconds  undo.log.delete.period = <span class="hljs-number">86400000</span>  undo.log.table = <span class="hljs-string">"undo_log"</span>&#125; ## metrics settingsmetrics &#123;  enabled = <span class="hljs-keyword">false</span>  registry-type = <span class="hljs-string">"compact"</span>  # multi exporters use comma divided  exporter-list = <span class="hljs-string">"prometheus"</span>  exporter-prometheus-port = <span class="hljs-number">9898</span>&#125; support &#123;  ## spring  spring &#123;    # auto proxy the DataSource bean    datasource.autoproxy = <span class="hljs-keyword">false</span>  &#125;&#125;</code></pre><p><strong>registry.conf</strong></p><pre><code class="hljs json">registry &#123;  # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa  type = "nacos"   nacos &#123;    serverAddr = "localhost:8848"    namespace = ""    cluster = "default"  &#125;  eureka &#123;    serviceUrl = "http://localhost:8761/eureka"    application = "default"    weight = "1"  &#125;  redis &#123;    serverAddr = "localhost:6379"    db = "0"  &#125;  zk &#123;    cluster = "default"    serverAddr = "127.0.0.1:2181"    session.timeout = 6000    connect.timeout = 2000  &#125;  consul &#123;    cluster = "default"    serverAddr = "127.0.0.1:8500"  &#125;  etcd3 &#123;    cluster = "default"    serverAddr = "http://localhost:2379"  &#125;  sofa &#123;    serverAddr = "127.0.0.1:9603"    application = "default"    region = "DEFAULT_ZONE"    datacenter = "DefaultDataCenter"    cluster = "default"    group = "SEATA_GROUP"    addressWaitTime = "3000"  &#125;  file &#123;    name = "file.conf"  &#125;&#125; config &#123;  # file、nacos 、apollo、zk、consul、etcd3  type = "file"   nacos &#123;    serverAddr = "localhost"    namespace = ""  &#125;  consul &#123;    serverAddr = "127.0.0.1:8500"  &#125;  apollo &#123;    app.id = "seata-server"    apollo.meta = "http://192.168.1.204:8801"  &#125;  zk &#123;    serverAddr = "127.0.0.1:2181"    session.timeout = 6000    connect.timeout = 2000  &#125;  etcd3 &#123;    serverAddr = "http://localhost:2379"  &#125;  file &#123;    name = "file.conf"  &#125;&#125;</code></pre><p><strong>实体类</strong></p><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-meta">@NoArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommonResult</span>&lt;<span class="hljs-title">T</span>&gt;</span><span class="hljs-class"></span>&#123;    <span class="hljs-keyword">private</span> Integer code;    <span class="hljs-keyword">private</span> String  message;    <span class="hljs-keyword">private</span> T       data;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CommonResult</span><span class="hljs-params">(Integer code, String message)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">this</span>(code,message,<span class="hljs-keyword">null</span>);    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-meta">@NoArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Order</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-keyword">private</span> Long id;     <span class="hljs-keyword">private</span> Long userId;     <span class="hljs-keyword">private</span> Long productId;     <span class="hljs-keyword">private</span> Integer count;     <span class="hljs-keyword">private</span> BigDecimal money;     <span class="hljs-keyword">private</span> Integer status; <span class="hljs-comment">//订单状态：0：创建中；1：已完结</span>&#125;</code></pre><p><strong>dao接口及实现</strong></p><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">OrderDao</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-comment">//新建订单</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">create</span><span class="hljs-params">(Order order)</span></span>;     <span class="hljs-comment">//修改订单状态，从零改为1</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(@Param(<span class="hljs-string">"userId"</span>)</span> Long userId,@<span class="hljs-title">Param</span><span class="hljs-params">(<span class="hljs-string">"status"</span>)</span> Integer status)</span>;&#125;</code></pre><p>mapper</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span> <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span> <span class="hljs-meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span> &gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">"com.atguigu.springcloud.alibaba.dao.OrderDao"</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"BaseResultMap"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"com.atguigu.springcloud.alibaba.domain.Order"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"BIGINT"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"user_id"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"userId"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"BIGINT"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"product_id"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"productId"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"BIGINT"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"count"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"count"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"INTEGER"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"money"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"money"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"DECIMAL"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"status"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"status"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"INTEGER"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"create"</span>&gt;</span>        insert into t_order (id,user_id,product_id,count,money,status)        values (null,#&#123;userId&#125;,#&#123;productId&#125;,#&#123;count&#125;,#&#123;money&#125;,0);    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"update"</span>&gt;</span>        update t_order set status = 1        where user_id=#&#123;userId&#125; and status = #&#123;status&#125;;    <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre><p><strong>Service</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">OrderService</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">create</span><span class="hljs-params">(Order order)</span></span>;&#125;</code></pre><p><strong>实现类</strong></p><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-meta">@Slf</span>4j<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OrderService</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> OrderDao orderDao;    <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> StorageService storageService;    <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> AccountService accountService;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 创建订单-&gt;调用库存服务扣减库存-&gt;调用账户服务扣减账户余额-&gt;修改订单状态</span><span class="hljs-comment">     */</span>         <span class="hljs-meta">@Override</span>    <span class="hljs-meta">@GlobalTransactional</span>(name = <span class="hljs-string">"fsp-create-order"</span>,rollbackFor = Exception<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">    <span class="hljs-title">public</span> <span class="hljs-title">void</span> <span class="hljs-title">create</span>(<span class="hljs-title">Order</span> <span class="hljs-title">order</span>)</span>&#123;        log.info(<span class="hljs-string">"-----&gt;开始新建订单"</span>);        <span class="hljs-comment">//新建订单</span>        orderDao.create(order);         <span class="hljs-comment">//扣减库存</span>        log.info(<span class="hljs-string">"-----&gt;订单微服务开始调用库存，做扣减Count"</span>);        storageService.decrease(order.getProductId(),order.getCount());        log.info(<span class="hljs-string">"-----&gt;订单微服务开始调用库存，做扣减end"</span>);         <span class="hljs-comment">//扣减账户</span>        log.info(<span class="hljs-string">"-----&gt;订单微服务开始调用账户，做扣减Money"</span>);        accountService.decrease(order.getUserId(),order.getMoney());        log.info(<span class="hljs-string">"-----&gt;订单微服务开始调用账户，做扣减end"</span>);                  <span class="hljs-comment">//修改订单状态，从零到1代表已经完成</span>        log.info(<span class="hljs-string">"-----&gt;修改订单状态开始"</span>);        orderDao.update(order.getUserId(),<span class="hljs-number">0</span>);        log.info(<span class="hljs-string">"-----&gt;修改订单状态结束"</span>);         log.info(<span class="hljs-string">"-----&gt;下订单结束了"</span>);     &#125;&#125;</code></pre><p><strong>OpenFeign 接口</strong></p><pre><code class="hljs java"><span class="hljs-meta">@FeignClient</span>(value = <span class="hljs-string">"seata-storage-service"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">StorageService</span></span>&#123;    <span class="hljs-meta">@PostMapping</span>(value = <span class="hljs-string">"/storage/decrease"</span>)    <span class="hljs-function">CommonResult <span class="hljs-title">decrease</span><span class="hljs-params">(@RequestParam(<span class="hljs-string">"productId"</span>)</span> Long productId, @<span class="hljs-title">RequestParam</span><span class="hljs-params">(<span class="hljs-string">"count"</span>)</span> Integer count)</span>;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-meta">@FeignClient</span>(value = <span class="hljs-string">"seata-account-service"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AccountService</span></span>&#123;    <span class="hljs-meta">@PostMapping</span>(value = <span class="hljs-string">"/account/decrease"</span>)    <span class="hljs-function">CommonResult <span class="hljs-title">decrease</span><span class="hljs-params">(@RequestParam(<span class="hljs-string">"userId"</span>)</span> Long userId, @<span class="hljs-title">RequestParam</span><span class="hljs-params">(<span class="hljs-string">"money"</span>)</span> BigDecimal money)</span>;&#125;</code></pre><p><strong>Controller</strong></p><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderController</span></span>&#123;    <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> OrderService orderService;      <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/order/create"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult <span class="hljs-title">create</span><span class="hljs-params">(Order order)</span></span><span class="hljs-function">    </span>&#123;        orderService.create(order);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CommonResult(<span class="hljs-number">200</span>,<span class="hljs-string">"订单创建成功"</span>);    &#125;&#125;</code></pre><p><strong>config</strong></p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@MapperScan</span>(&#123;<span class="hljs-string">"com.atguigu.springcloud.alibaba.dao"</span>&#125;)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBatisConfig</span> </span>&#123; &#125;</code></pre><pre><code class="hljs java">  <span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataSourceProxyConfig</span> </span>&#123;      <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;mybatis.mapperLocations&#125;"</span>)    <span class="hljs-keyword">private</span> String mapperLocations;         <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"spring.datasource"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">druidDataSource</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DruidDataSource();    &#125;         <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSourceProxy <span class="hljs-title">dataSourceProxy</span><span class="hljs-params">(DataSource dataSource)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DataSourceProxy(dataSource);    &#125;         <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> SqlSessionFactory <span class="hljs-title">sqlSessionFactoryBean</span><span class="hljs-params">(DataSourceProxy dataSourceProxy)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        SqlSessionFactoryBean sqlSessionFactoryBean = <span class="hljs-keyword">new</span> SqlSessionFactoryBean();        sqlSessionFactoryBean.setDataSource(dataSourceProxy);        sqlSessionFactoryBean.setMapperLocations(<span class="hljs-keyword">new</span> PathMatchingResourcePatternResolver().getResources(mapperLocations));        sqlSessionFactoryBean.setTransactionFactory(<span class="hljs-keyword">new</span> SpringManagedTransactionFactory());        <span class="hljs-keyword">return</span> sqlSessionFactoryBean.getObject();    &#125;&#125;</code></pre><p>主启动类</p><pre><code class="hljs java">  <span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataSourceProxyConfig</span> </span>&#123;      <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;mybatis.mapperLocations&#125;"</span>)    <span class="hljs-keyword">private</span> String mapperLocations;         <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"spring.datasource"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">druidDataSource</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DruidDataSource();    &#125;         <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSourceProxy <span class="hljs-title">dataSourceProxy</span><span class="hljs-params">(DataSource dataSource)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DataSourceProxy(dataSource);    &#125;         <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> SqlSessionFactory <span class="hljs-title">sqlSessionFactoryBean</span><span class="hljs-params">(DataSourceProxy dataSourceProxy)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        SqlSessionFactoryBean sqlSessionFactoryBean = <span class="hljs-keyword">new</span> SqlSessionFactoryBean();        sqlSessionFactoryBean.setDataSource(dataSourceProxy);        sqlSessionFactoryBean.setMapperLocations(<span class="hljs-keyword">new</span> PathMatchingResourcePatternResolver().getResources(mapperLocations));        sqlSessionFactoryBean.setTransactionFactory(<span class="hljs-keyword">new</span> SpringManagedTransactionFactory());        <span class="hljs-keyword">return</span> sqlSessionFactoryBean.getObject();    &#125; &#125;</code></pre><h4 id="库存"><a href="#库存" class="headerlink" title="库存"></a>库存</h4><p><strong>pom</strong></p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>       <span class="hljs-comment">&lt;!--nacos--&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>       <span class="hljs-comment">&lt;!--seata--&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>                   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>seata-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.seata<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>               <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>           <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.seata<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>seata-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>       <span class="hljs-comment">&lt;!--feign--&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.37<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre><p><strong>YML</strong></p><pre><code class="hljs java">server:  port: <span class="hljs-number">2002</span> spring:  application:    name: seata-storage-service  cloud:    alibaba:      seata:        tx-service-group: fsp_tx_group    nacos:      discovery:        server-addr: localhost:<span class="hljs-number">8848</span>  datasource:    driver-class-name: com.mysql.jdbc.Driver    url: jdbc:mysql:<span class="hljs-comment">//localhost:3306/seata_storage</span>    username: root    password: <span class="hljs-number">111111</span> logging:  level:    io:      seata: info mybatis:  mapperLocations: classpath:mapper<span class="hljs-comment">/*.xml</span></code></pre><p><strong>file.conf</strong></p><pre><code class="hljs json">transport &#123;  # tcp udt unix-domain-socket  type = "TCP"  #NIO NATIVE  server = "NIO"  #enable heartbeat  heartbeat = true  #thread factory for netty  thread-factory &#123;    boss-thread-prefix = "NettyBoss"    worker-thread-prefix = "NettyServerNIOWorker"    server-executor-thread-prefix = "NettyServerBizHandler"    share-boss-worker = false    client-selector-thread-prefix = "NettyClientSelector"    client-selector-thread-size = 1    client-worker-thread-prefix = "NettyClientWorkerThread"    # netty boss thread size,will not be used for UDT    boss-thread-size = 1    #auto default pin or 8    worker-thread-size = 8  &#125;  shutdown &#123;    # when destroy server, wait seconds    wait = 3  &#125;  serialization = "seata"  compressor = "none"&#125; service &#123;  #vgroup-&gt;rgroup  vgroup_mapping.fsp_tx_group = "default"  #only support single node  default.grouplist = "127.0.0.1:8091"  #degrade current not support  enableDegrade = false  #disable  disable = false  #unit ms,s,m,h,d represents milliseconds, seconds, minutes, hours, days, default permanent  max.commit.retry.timeout = "-1"  max.rollback.retry.timeout = "-1"  disableGlobalTransaction = false&#125; client &#123;  async.commit.buffer.limit = 10000  lock &#123;    retry.internal = 10    retry.times = 30  &#125;  report.retry.count = 5  tm.commit.retry.count = 1  tm.rollback.retry.count = 1&#125; transaction &#123;  undo.data.validation = true  undo.log.serialization = "jackson"  undo.log.save.days = 7  #schedule delete expired undo_log in milliseconds  undo.log.delete.period = 86400000  undo.log.table = "undo_log"&#125; support &#123;  ## spring  spring &#123;    # auto proxy the DataSource bean    datasource.autoproxy = false  &#125;&#125;</code></pre><p><strong>registry.conf</strong></p><pre><code class="hljs java">registry &#123;  # file 、nacos 、eureka、redis、zk  type = <span class="hljs-string">"nacos"</span>   nacos &#123;    serverAddr = <span class="hljs-string">"localhost:8848"</span>    namespace = <span class="hljs-string">""</span>    cluster = <span class="hljs-string">"default"</span>  &#125;  eureka &#123;    serviceUrl = <span class="hljs-string">"http://localhost:8761/eureka"</span>    application = <span class="hljs-string">"default"</span>    weight = <span class="hljs-string">"1"</span>  &#125;  redis &#123;    serverAddr = <span class="hljs-string">"localhost:6381"</span>    db = <span class="hljs-string">"0"</span>  &#125;  zk &#123;    cluster = <span class="hljs-string">"default"</span>    serverAddr = <span class="hljs-string">"127.0.0.1:2181"</span>    session.timeout = <span class="hljs-number">6000</span>    connect.timeout = <span class="hljs-number">2000</span>  &#125;  file &#123;    name = <span class="hljs-string">"file.conf"</span>  &#125;&#125; config &#123;  # file、nacos 、apollo、zk  type = <span class="hljs-string">"file"</span>   nacos &#123;    serverAddr = <span class="hljs-string">"localhost"</span>    namespace = <span class="hljs-string">""</span>    cluster = <span class="hljs-string">"default"</span>  &#125;  apollo &#123;    app.id = <span class="hljs-string">"fescar-server"</span>    apollo.meta = <span class="hljs-string">"http://192.168.1.204:8801"</span>  &#125;  zk &#123;    serverAddr = <span class="hljs-string">"127.0.0.1:2181"</span>    session.timeout = <span class="hljs-number">6000</span>    connect.timeout = <span class="hljs-number">2000</span>  &#125;  file &#123;    name = <span class="hljs-string">"file.conf"</span>  &#125;&#125;</code></pre><p><strong>实体类</strong></p><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-meta">@NoArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommonResult</span>&lt;<span class="hljs-title">T</span>&gt;</span><span class="hljs-class"></span>&#123;    <span class="hljs-keyword">private</span> Integer code;    <span class="hljs-keyword">private</span> String  message;    <span class="hljs-keyword">private</span> T       data;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CommonResult</span><span class="hljs-params">(Integer code, String message)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">this</span>(code,message,<span class="hljs-keyword">null</span>);    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Storage</span> </span>&#123;     <span class="hljs-keyword">private</span> Long id;     <span class="hljs-comment">// 产品id</span>    <span class="hljs-keyword">private</span> Long productId;     <span class="hljs-comment">//总库存</span>    <span class="hljs-keyword">private</span> Integer total;      <span class="hljs-comment">//已用库存</span>    <span class="hljs-keyword">private</span> Integer used;       <span class="hljs-comment">//剩余库存</span>    <span class="hljs-keyword">private</span> Integer residue;&#125;</code></pre><p><strong>dao接口及实现</strong></p><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">StorageDao</span> </span>&#123;      <span class="hljs-comment">//扣减库存信息</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">decrease</span><span class="hljs-params">(@Param(<span class="hljs-string">"productId"</span>)</span> Long productId, @<span class="hljs-title">Param</span><span class="hljs-params">(<span class="hljs-string">"count"</span>)</span> Integer count)</span>;&#125;</code></pre><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span> <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span> <span class="hljs-meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span> &gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">"com.atguigu.springcloud.alibaba.dao.StorageDao"</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"BaseResultMap"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"com.atguigu.springcloud.alibaba.domain.Storage"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"BIGINT"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"product_id"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"productId"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"BIGINT"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"total"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"total"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"INTEGER"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"used"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"used"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"INTEGER"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"residue"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"residue"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"INTEGER"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"decrease"</span>&gt;</span>        UPDATE            t_storage        SET            used = used + #&#123;count&#125;,residue = residue - #&#123;count&#125;        WHERE            product_id = #&#123;productId&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre><p><strong>Service接口及实现</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">StorageService</span> </span>&#123;         <span class="hljs-comment">// 扣减库存</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">decrease</span><span class="hljs-params">(Long productId, Integer count)</span></span>;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StorageServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">StorageService</span> </span>&#123;     <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(StorageServiceImpl<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;     <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> StorageDao storageDao;      <span class="hljs-comment">// 扣减库存</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrease</span><span class="hljs-params">(Long productId, Integer count)</span> </span>&#123;        LOGGER.info(<span class="hljs-string">"-------&gt;storage-service中扣减库存开始"</span>);        storageDao.decrease(productId,count);        LOGGER.info(<span class="hljs-string">"-------&gt;storage-service中扣减库存结束"</span>);    &#125;&#125;</code></pre><p><strong>Controllrer</strong></p><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StorageController</span> </span>&#123;     <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> StorageService storageService;      <span class="hljs-comment">//扣减库存</span>    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/storage/decrease"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult <span class="hljs-title">decrease</span><span class="hljs-params">(Long productId, Integer count)</span> </span>&#123;        storageService.decrease(productId, count);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CommonResult(<span class="hljs-number">200</span>,<span class="hljs-string">"扣减库存成功！"</span>);    &#125;&#125;</code></pre><p><strong>config</strong></p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@MapperScan</span>(&#123;<span class="hljs-string">"com.atguigu.springcloud.alibaba.dao"</span>&#125;)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBatisConfig</span> </span>&#123;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataSourceProxyConfig</span> </span>&#123;     <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;mybatis.mapperLocations&#125;"</span>)    <span class="hljs-keyword">private</span> String mapperLocations;     <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"spring.datasource"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">druidDataSource</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DruidDataSource();    &#125;     <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSourceProxy <span class="hljs-title">dataSourceProxy</span><span class="hljs-params">(DataSource dataSource)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DataSourceProxy(dataSource);    &#125;     <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> SqlSessionFactory <span class="hljs-title">sqlSessionFactoryBean</span><span class="hljs-params">(DataSourceProxy dataSourceProxy)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        SqlSessionFactoryBean sqlSessionFactoryBean = <span class="hljs-keyword">new</span> SqlSessionFactoryBean();        sqlSessionFactoryBean.setDataSource(dataSourceProxy);        sqlSessionFactoryBean.setMapperLocations(<span class="hljs-keyword">new</span> PathMatchingResourcePatternResolver().getResources(mapperLocations));        sqlSessionFactoryBean.setTransactionFactory(<span class="hljs-keyword">new</span> SpringManagedTransactionFactory());        <span class="hljs-keyword">return</span> sqlSessionFactoryBean.getObject();    &#125; &#125;</code></pre><p><strong>启动类</strong></p><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span>(exclude = DataSourceAutoConfiguration<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">@<span class="hljs-title">EnableDiscoveryClient</span></span><span class="hljs-class">@<span class="hljs-title">EnableFeignClients</span></span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">SeataStorageServiceApplication2002</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><span class="hljs-function">    </span>&#123;        SpringApplication.run(SeataStorageServiceApplication2002<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="账户"><a href="#账户" class="headerlink" title="账户"></a>账户</h4><p><strong>POM</strong></p><pre><code class="hljs java">&lt;dependencies&gt;       &lt;!--nacos--&gt;       &lt;dependency&gt;           &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;           &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;       &lt;/dependency&gt;       &lt;!--seata--&gt;       &lt;dependency&gt;           &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;           &lt;artifactId&gt;spring-cloud-starter-alibaba-seata&lt;/artifactId&gt;           &lt;exclusions&gt;               &lt;exclusion&gt;                   &lt;artifactId&gt;seata-all&lt;/artifactId&gt;                   &lt;groupId&gt;io.seata&lt;/groupId&gt;               &lt;/exclusion&gt;           &lt;/exclusions&gt;       &lt;/dependency&gt;       &lt;dependency&gt;           &lt;groupId&gt;io.seata&lt;/groupId&gt;           &lt;artifactId&gt;seata-all&lt;/artifactId&gt;           &lt;version&gt;0.9.0&lt;/version&gt;       &lt;/dependency&gt;       &lt;!--feign--&gt;       &lt;dependency&gt;           &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;           &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;       &lt;/dependency&gt;       &lt;dependency&gt;           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;           &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;       &lt;/dependency&gt;       &lt;dependency&gt;           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;           &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;           &lt;scope&gt;test&lt;/scope&gt;       &lt;/dependency&gt;       &lt;dependency&gt;           &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;           &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;           &lt;version&gt;2.0.0&lt;/version&gt;       &lt;/dependency&gt;       &lt;dependency&gt;           &lt;groupId&gt;mysql&lt;/groupId&gt;           &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;           &lt;version&gt;5.1.37&lt;/version&gt;       &lt;/dependency&gt;       &lt;dependency&gt;           &lt;groupId&gt;com.alibaba&lt;/groupId&gt;           &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;           &lt;version&gt;1.1.10&lt;/version&gt;       &lt;/dependency&gt;       &lt;dependency&gt;           &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;           &lt;artifactId&gt;lombok&lt;/artifactId&gt;           &lt;optional&gt;true&lt;/optional&gt;       &lt;/dependency&gt;   &lt;/dependencies&gt;</code></pre><p><strong>YML</strong></p><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">2003</span> <span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">seata-account-service</span>  <span class="hljs-attr">cloud:</span>    <span class="hljs-attr">alibaba:</span>      <span class="hljs-attr">seata:</span>        <span class="hljs-attr">tx-service-group:</span> <span class="hljs-string">fsp_tx_group</span>    <span class="hljs-attr">nacos:</span>      <span class="hljs-attr">discovery:</span>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span>  <span class="hljs-attr">datasource:</span>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.jdbc.Driver</span>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/seata_account</span>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span>    <span class="hljs-attr">password:</span> <span class="hljs-number">1111111</span> <span class="hljs-attr">feign:</span>  <span class="hljs-attr">hystrix:</span>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span> <span class="hljs-attr">logging:</span>  <span class="hljs-attr">level:</span>    <span class="hljs-attr">io:</span>      <span class="hljs-attr">seata:</span> <span class="hljs-string">info</span> <span class="hljs-attr">mybatis:</span>  <span class="hljs-attr">mapperLocations:</span> <span class="hljs-string">classpath:mapper/*.xml</span></code></pre><p><strong>file.conf</strong></p><pre><code class="hljs json">transport &#123;  # tcp udt unix-domain-socket  type = "TCP"  #NIO NATIVE  server = "NIO"  #enable heartbeat  heartbeat = true  #thread factory for netty  thread-factory &#123;    boss-thread-prefix = "NettyBoss"    worker-thread-prefix = "NettyServerNIOWorker"    server-executor-thread-prefix = "NettyServerBizHandler"    share-boss-worker = false    client-selector-thread-prefix = "NettyClientSelector"    client-selector-thread-size = 1    client-worker-thread-prefix = "NettyClientWorkerThread"    # netty boss thread size,will not be used for UDT    boss-thread-size = 1    #auto default pin or 8    worker-thread-size = 8  &#125;  shutdown &#123;    # when destroy server, wait seconds    wait = 3  &#125;  serialization = "seata"  compressor = "none"&#125; service &#123;   vgroup_mapping.fsp_tx_group = "default" #修改自定义事务组名称   default.grouplist = "127.0.0.1:8091"  enableDegrade = false  disable = false  max.commit.retry.timeout = "-1"  max.rollback.retry.timeout = "-1"  disableGlobalTransaction = false&#125;  client &#123;  async.commit.buffer.limit = 10000  lock &#123;    retry.internal = 10    retry.times = 30  &#125;  report.retry.count = 5  tm.commit.retry.count = 1  tm.rollback.retry.count = 1&#125; ## transaction log storestore &#123;  ## store mode: file、db  mode = "db"   ## file store  file &#123;    dir = "sessionStore"     # branch session size , if exceeded first try compress lockkey, still exceeded throws exceptions    max-branch-session-size = 16384    # globe session size , if exceeded throws exceptions    max-global-session-size = 512    # file buffer size , if exceeded allocate new buffer    file-write-buffer-cache-size = 16384    # when recover batch read size    session.reload.read_size = 100    # async, sync    flush-disk-mode = async  &#125;   ## database store  db &#123;    ## the implement of javax.sql.DataSource, such as DruidDataSource(druid)/BasicDataSource(dbcp) etc.    datasource = "dbcp"    ## mysql/oracle/h2/oceanbase etc.    db-type = "mysql"    driver-class-name = "com.mysql.jdbc.Driver"    url = "jdbc:mysql://127.0.0.1:3306/seata"    user = "root"    password = "123456"    min-conn = 1    max-conn = 3    global.table = "global_table"    branch.table = "branch_table"    lock-table = "lock_table"    query-limit = 100  &#125;&#125;lock &#123;  ## the lock store mode: local、remote  mode = "remote"   local &#123;    ## store locks in user's database  &#125;   remote &#123;    ## store locks in the seata's server  &#125;&#125;recovery &#123;  #schedule committing retry period in milliseconds  committing-retry-period = 1000  #schedule asyn committing retry period in milliseconds  asyn-committing-retry-period = 1000  #schedule rollbacking retry period in milliseconds  rollbacking-retry-period = 1000  #schedule timeout retry period in milliseconds  timeout-retry-period = 1000&#125; transaction &#123;  undo.data.validation = true  undo.log.serialization = "jackson"  undo.log.save.days = 7  #schedule delete expired undo_log in milliseconds  undo.log.delete.period = 86400000  undo.log.table = "undo_log"&#125; ## metrics settingsmetrics &#123;  enabled = false  registry-type = "compact"  # multi exporters use comma divided  exporter-list = "prometheus"  exporter-prometheus-port = 9898&#125; support &#123;  ## spring  spring &#123;    # auto proxy the DataSource bean    datasource.autoproxy = false  &#125;&#125;</code></pre><p><strong>registry.conf</strong></p><pre><code class="hljs json">registry &#123;  # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa  type = "nacos"   nacos &#123;    serverAddr = "localhost:8848"    namespace = ""    cluster = "default"  &#125;  eureka &#123;    serviceUrl = "http://localhost:8761/eureka"    application = "default"    weight = "1"  &#125;  redis &#123;    serverAddr = "localhost:6379"    db = "0"  &#125;  zk &#123;    cluster = "default"    serverAddr = "127.0.0.1:2181"    session.timeout = 6000    connect.timeout = 2000  &#125;  consul &#123;    cluster = "default"    serverAddr = "127.0.0.1:8500"  &#125;  etcd3 &#123;    cluster = "default"    serverAddr = "http://localhost:2379"  &#125;  sofa &#123;    serverAddr = "127.0.0.1:9603"    application = "default"    region = "DEFAULT_ZONE"    datacenter = "DefaultDataCenter"    cluster = "default"    group = "SEATA_GROUP"    addressWaitTime = "3000"  &#125;  file &#123;    name = "file.conf"  &#125;&#125; config &#123;  # file、nacos 、apollo、zk、consul、etcd3  type = "file"   nacos &#123;    serverAddr = "localhost"    namespace = ""  &#125;  consul &#123;    serverAddr = "127.0.0.1:8500"  &#125;  apollo &#123;    app.id = "seata-server"    apollo.meta = "http://192.168.1.204:8801"  &#125;  zk &#123;    serverAddr = "127.0.0.1:2181"    session.timeout = 6000    connect.timeout = 2000  &#125;  etcd3 &#123;    serverAddr = "http://localhost:2379"  &#125;  file &#123;    name = "file.conf"  &#125;&#125;</code></pre><p><strong>实体类</strong></p><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-meta">@NoArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommonResult</span>&lt;<span class="hljs-title">T</span>&gt;</span><span class="hljs-class"></span>&#123;    <span class="hljs-keyword">private</span> Integer code;    <span class="hljs-keyword">private</span> String  message;    <span class="hljs-keyword">private</span> T       data;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CommonResult</span><span class="hljs-params">(Integer code, String message)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">this</span>(code,message,<span class="hljs-keyword">null</span>);    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-meta">@NoArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span> </span>&#123;     <span class="hljs-keyword">private</span> Long id;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 用户id</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> Long userId;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 总额度</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> BigDecimal total;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 已用额度</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> BigDecimal used;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 剩余额度</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> BigDecimal residue;&#125;</code></pre><p><strong>dao层及实现</strong></p><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AccountDao</span> </span>&#123;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 扣减账户余额</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">decrease</span><span class="hljs-params">(@Param(<span class="hljs-string">"userId"</span>)</span> Long userId, @<span class="hljs-title">Param</span><span class="hljs-params">(<span class="hljs-string">"money"</span>)</span> BigDecimal money)</span>;&#125;</code></pre><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span> <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span> <span class="hljs-meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span> &gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">"com.atguigu.springcloud.alibaba.dao.AccountDao"</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"BaseResultMap"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"com.atguigu.springcloud.alibaba.domain.Account"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"BIGINT"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"user_id"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"userId"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"BIGINT"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"total"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"total"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"DECIMAL"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"used"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"used"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"DECIMAL"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"residue"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"residue"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"DECIMAL"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"decrease"</span>&gt;</span>        UPDATE t_account        SET          residue = residue - #&#123;money&#125;,used = used + #&#123;money&#125;        WHERE          user_id = #&#123;userId&#125;;    <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre><p><strong>Service接口及实现</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AccountService</span> </span>&#123;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 扣减账户余额</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">decrease</span><span class="hljs-params">(@RequestParam(<span class="hljs-string">"userId"</span>)</span> Long userId, @<span class="hljs-title">RequestParam</span><span class="hljs-params">(<span class="hljs-string">"money"</span>)</span> BigDecimal money)</span>;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 账户业务实现类</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AccountService</span> </span>&#123;     <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(AccountServiceImpl<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;      <span class="hljs-meta">@Resource</span>    AccountDao accountDao;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 扣减账户余额</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrease</span><span class="hljs-params">(Long userId, BigDecimal money)</span> </span>&#123;                 LOGGER.info(<span class="hljs-string">"-------&gt;account-service中扣减账户余额开始"</span>);        <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">20</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;        accountDao.decrease(userId,money);        LOGGER.info(<span class="hljs-string">"-------&gt;account-service中扣减账户余额结束"</span>);    &#125;&#125;</code></pre><p><strong>Controllrer</strong></p><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountController</span> </span>&#123;     <span class="hljs-meta">@Resource</span>    AccountService accountService;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 扣减账户余额</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/account/decrease"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult <span class="hljs-title">decrease</span><span class="hljs-params">(@RequestParam(<span class="hljs-string">"userId"</span>)</span> Long userId, @<span class="hljs-title">RequestParam</span><span class="hljs-params">(<span class="hljs-string">"money"</span>)</span> BigDecimal money)</span>&#123;        accountService.decrease(userId,money);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CommonResult(<span class="hljs-number">200</span>,<span class="hljs-string">"扣减账户余额成功！"</span>);    &#125;&#125;</code></pre><p><strong>config</strong></p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@MapperScan</span>(&#123;<span class="hljs-string">"com.atguigu.springcloud.alibaba.dao"</span>&#125;)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBatisConfig</span> </span>&#123; &#125;</code></pre><pre><code class="hljs java"> <span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataSourceProxyConfig</span> </span>&#123;     <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;mybatis.mapperLocations&#125;"</span>)    <span class="hljs-keyword">private</span> String mapperLocations;     <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"spring.datasource"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">druidDataSource</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DruidDataSource();    &#125;     <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSourceProxy <span class="hljs-title">dataSourceProxy</span><span class="hljs-params">(DataSource dataSource)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DataSourceProxy(dataSource);    &#125;     <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> SqlSessionFactory <span class="hljs-title">sqlSessionFactoryBean</span><span class="hljs-params">(DataSourceProxy dataSourceProxy)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        SqlSessionFactoryBean sqlSessionFactoryBean = <span class="hljs-keyword">new</span> SqlSessionFactoryBean();        sqlSessionFactoryBean.setDataSource(dataSourceProxy);        sqlSessionFactoryBean.setMapperLocations(<span class="hljs-keyword">new</span> PathMatchingResourcePatternResolver().getResources(mapperLocations));        sqlSessionFactoryBean.setTransactionFactory(<span class="hljs-keyword">new</span> SpringManagedTransactionFactory());        <span class="hljs-keyword">return</span> sqlSessionFactoryBean.getObject();    &#125; &#125;</code></pre><p><strong>启动类</strong></p><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span>(exclude = DataSourceAutoConfiguration<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">@<span class="hljs-title">EnableDiscoveryClient</span></span><span class="hljs-class">@<span class="hljs-title">EnableFeignClients</span></span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">SeataAccountMainApp2003</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><span class="hljs-function">    </span>&#123;        SpringApplication.run(SeataAccountMainApp2003<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>可以测试正常下单情况</p><p>添加超时异常 没加@GlobalTransactional情况</p><p><strong style="color:blue">当库存和账户余额扣减后，订单状态并没有设置为已经完成，没有从零改为1<br>而且由于feign的重试机制，账户余额还有可能被多次扣减</strong></p><p>添加超时异常  加@GlobalTransactional</p><p><strong style="color:blue">记录都添加不进来<br>下单后数据库数据并没有任何改变</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记/微服务/9-2-0springcloudAlibabaSeata分布式事务处理简介</title>
    <link href="/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/9-2-0springcloudAlibabaSeata%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%AE%80%E4%BB%8B/"/>
    <url>/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/9-2-0springcloudAlibabaSeata%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="分布式面临的问题"><a href="#分布式面临的问题" class="headerlink" title="分布式面临的问题"></a>分布式面临的问题</h3><p>单体应用被拆分成微服务应用，原来的三个模块被拆分成三个独立的应用，分别使用三个独立的数据源,<br>业务操作需要调用三个服务来完成。此时每个服务内部的数据一致性由本地事务来保证，但是全局的数据—致性问题没法保证。</p><p>ps:<strong style="color:red">一次业务操作需要跨多个数据源或需要跨多个系统进行远程调用，就会产生分布式事务的问题</strong></p><h3 id="Seata简介"><a href="#Seata简介" class="headerlink" title="Seata简介"></a>Seata简介</h3><p>是一款开源的分布式事务解决方案，致力在微服务架构下提供高性能和简单易用的分布式事务服务</p><p><a href="https://seata.io/zh-cn/docs/overview/what-is-seata.html" target="_blank" rel="noopener">地址</a></p><p><strong>能干嘛</strong></p><p>​    一个典型的分布式事务过程</p><ol><li>TM向TC申请一个开启一个全局事务，全局事务创建成功并生成一个全局的唯一XID</li><li>XID 在微服务调用链路上下文中传播</li><li>RM向TC注册分支事务，将其纳入XID对应全局事务</li><li>TM向TC发起针对XID的全局提交或回滚决议，</li><li>TC调度XID下管辖的全部分支事务完成提交或回滚请求</li></ol><p><img src="D:%5C%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE%5C%E5%8D%9A%E5%AE%A2%5Cimage-20201117214543665.png" srcset="/img/loading.gif" alt="image-20201117214543665"></p><p>分布式事务处理过程-ID+三组件模型</p><ul><li><p><strong>Transaction ID XID：</strong>全局唯一的事务ID</p></li><li><p><strong>Transaction Coordinator(TC):</strong>事务协调器，维护全局事务的运行状态，负责协调并驱动全局事务的提交或回滚。</p></li><li><p><strong>lransaction Manager(TM)：</strong>控制全局事务的边界，负责开启一个全局事务，并最终发起全局提交或全局回滚的决议。</p></li><li><p><strong>Resource Manager(RM)：</strong>控制分支事务，负责分支注册，状态汇报。并接收事务协调器的指令，驱动分支（本地）事务的提交和回滚。</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记/微服务/9-1-3springcloudAlibabaSentinel 持久化 配置</title>
    <link href="/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/9-1-3springcloudAlibabaSentinel%20%E6%8C%81%E4%B9%85%E5%8C%96%20%E9%85%8D%E7%BD%AE/"/>
    <url>/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/9-1-3springcloudAlibabaSentinel%20%E6%8C%81%E4%B9%85%E5%8C%96%20%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>原因：<strong style="color:red">一旦我们重启了应用，sentinel规则将会消失，生产环境需要将配置规则进行持久化</strong></p><h3 id="怎么解决？"><a href="#怎么解决？" class="headerlink" title="怎么解决？"></a>怎么解决？</h3><p>将限流配置规则持久化进Nacos保存，只要刷新8401某个rest地址，sentinel控制台的流控规则就能看到，只要Nacov里面的配置不出除，针对341上Sentinel上的流控规则持续有效</p><p>修改8401 服务yml 配置</p><pre><code class="hljs java">server:  port: <span class="hljs-number">8401</span>spring:  application:    name: cloudalibaba-sentinel-service  cloud:    nacos:      discovery:        server-addr: localhost:8848 #Nacos服务注册中心地址    sentinel:      transport:        dashboard: localhost:8080 #配置Sentinel dashboard地址        port: <span class="hljs-number">8719</span>      datasource:        ds1:          nacos:            server-addr: localhost:<span class="hljs-number">8848</span>            dataId: cloudalibaba-sentinel-service            groupId: DEFAULT_GROUP            data-type: json            rule-type: flowmanagement:  endpoints:    web:      exposure:        include: <span class="hljs-string">'*'</span>feign:  sentinel:    enabled: true # 激活Sentinel对Feign的支持</code></pre><h3 id="新建Nacos业务规则配置"><a href="#新建Nacos业务规则配置" class="headerlink" title="新建Nacos业务规则配置"></a>新建Nacos业务规则配置</h3><p><img src="D:%5C%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE%5C%E5%8D%9A%E5%AE%A2%5Cimage-20201107221045823.png" srcset="/img/loading.gif" alt="image-20201107221045823"></p><p><strong>配置解析</strong></p><ul><li>resource：资源名称。</li><li>limitApp: 来源应用；</li><li>grade: 阈值类型，0 线程数 1 QPS</li><li>count: 单机阈值</li><li>strategy: 流控模式，0表示直接 1 表示关联 2 表示链路</li><li>controlBehavior: 流控效果， 0 表示快速失败，1表示Warm, 2 表示排队等待</li><li>clusterMode: 是否集群 </li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记/微服务/9-1-2springcloudAlibabaSentinel 整合 ribbon,openFeign,fallback</title>
    <link href="/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/9-1-2springcloudAlibabaSentinel%20%E6%95%B4%E5%90%88%20ribbon,openFeign,fallback/"/>
    <url>/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/9-1-2springcloudAlibabaSentinel%20%E6%95%B4%E5%90%88%20ribbon,openFeign,fallback/</url>
    
    <content type="html"><![CDATA[<h3 id="新建服务提供者"><a href="#新建服务提供者" class="headerlink" title="新建服务提供者"></a>新建服务提供者</h3><p>POM</p><pre><code class="hljs java">&lt;dependency&gt;        &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;    &lt;/dependency&gt;</code></pre><p><strong>yml</strong></p><pre><code class="hljs java">server:  port: <span class="hljs-number">9003</span>spring:  application:    name: nacos-payment-provider  cloud:    nacos:      discovery:        server-addr: localhost:8848 #配置Nacos地址management:  endpoints:    web:      exposure:        include: <span class="hljs-string">'*'</span></code></pre><p><strong>启动类</strong></p><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableDiscoveryClient</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaymentMain9003</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(PaymentMain9003<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre><p><strong>controller</strong></p><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaymentController</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;server.port&#125;"</span>)    <span class="hljs-keyword">private</span> String serverPort;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> HashMap&lt;Long, Payment&gt; hashMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-keyword">static</span>&#123;        hashMap.put(<span class="hljs-number">1L</span>,<span class="hljs-keyword">new</span> Payment(<span class="hljs-number">1L</span>,<span class="hljs-string">"28a8c1e3bc2742d8848569891fb42181"</span>));        hashMap.put(<span class="hljs-number">2L</span>,<span class="hljs-keyword">new</span> Payment(<span class="hljs-number">2L</span>,<span class="hljs-string">"bba8c1e3bc2742d8848569891ac32182"</span>));        hashMap.put(<span class="hljs-number">3L</span>,<span class="hljs-keyword">new</span> Payment(<span class="hljs-number">3L</span>,<span class="hljs-string">"6ua8c1e3bc2742d8848569891xt92183"</span>));    &#125;    <span class="hljs-meta">@GetMapping</span>(value = <span class="hljs-string">"/paymentSQL/&#123;id&#125;"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult&lt;Payment&gt; <span class="hljs-title">paymentSQL</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> Long id)</span>&#123;        Payment payment = hashMap.get(id);        CommonResult&lt;Payment&gt; result = <span class="hljs-keyword">new</span> CommonResult(<span class="hljs-number">200</span>,<span class="hljs-string">"from mysql,serverPort:  "</span>+serverPort,payment);        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre><h3 id="新建服务消费者"><a href="#新建服务消费者" class="headerlink" title="新建服务消费者"></a>新建服务消费者</h3><p><strong>POM</strong></p><pre><code class="hljs java">&lt;dependency&gt;         &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;         &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;         &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;         &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;     &lt;/dependency&gt;</code></pre><p>YML</p><pre><code class="hljs java">server:  port: <span class="hljs-number">84</span>spring:  application:    name: nacos-order-consumer  cloud:    nacos:      discovery:        server-addr: localhost:<span class="hljs-number">8848</span>    sentinel:      transport:        dashboard: localhost:<span class="hljs-number">8080</span>        port: <span class="hljs-number">8719</span>service-url:  nacos-user-service: http:<span class="hljs-comment">//nacos-payment-provider</span></code></pre><p><strong>启动类</strong></p><pre><code class="hljs java"><span class="hljs-meta">@EnableDiscoveryClient</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableFeignClients</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderNacosMain84</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(OrderNacosMain84<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre><p><strong>配置负载均衡</strong></p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApplicationContextConfig</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@LoadBalanced</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">getRestTemplate</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();    &#125;&#125;</code></pre><p><strong>Controller</strong></p><pre><code class="hljs java">RestController<span class="hljs-meta">@Slf</span>4j<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CircleBreakerController</span> </span>&#123;       <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String SERVICE_URL = <span class="hljs-string">"http://nacos-payment-provider"</span>;    <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;           <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/consumer/fallback/&#123;id&#125;"</span>)    <span class="hljs-comment">//@SentinelResource(value = "fallback") //没有配置</span>    <span class="hljs-comment">//@SentinelResource(value = "fallback",fallback = "handlerFallback") //fallback只负责业务异常</span>    <span class="hljs-comment">//@SentinelResource(value = "fallback",blockHandler = "blockHandler") //blockHandler只负责sentinel控制台配置违规</span>    <span class="hljs-meta">@SentinelResource</span>(value = <span class="hljs-string">"fallback"</span>,fallback = <span class="hljs-string">"handlerFallback"</span>,blockHandler = <span class="hljs-string">"blockHandler"</span>,            exceptionsToIgnore = &#123;IllegalArgumentException<span class="hljs-class">.<span class="hljs-keyword">class</span>&#125;) // 忽略 假如报这个异常错误不会触发<span class="hljs-title">fallback</span>方法兜底，没有兜底</span><span class="hljs-class">    <span class="hljs-title">public</span> <span class="hljs-title">CommonResult</span>&lt;<span class="hljs-title">Payment</span>&gt; <span class="hljs-title">fallback</span>(@<span class="hljs-title">PathVariable</span> <span class="hljs-title">Long</span> <span class="hljs-title">id</span>) </span>&#123;        CommonResult&lt;Payment&gt; result = restTemplate.getForObject(SERVICE_URL + <span class="hljs-string">"/paymentSQL/"</span>+id, CommonResult<span class="hljs-class">.<span class="hljs-keyword">class</span>,<span class="hljs-title">id</span>)</span>;        <span class="hljs-keyword">if</span> (id == <span class="hljs-number">4</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException (<span class="hljs-string">"IllegalArgumentException,非法参数异常...."</span>);        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result.getData() == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException (<span class="hljs-string">"NullPointerException,该ID没有对应记录,空指针异常"</span>);        &#125;        <span class="hljs-keyword">return</span> result;    &#125;      <span class="hljs-comment">//fallback</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult <span class="hljs-title">handlerFallback</span><span class="hljs-params">(@PathVariable  Long id,Throwable e)</span> </span>&#123;        Payment payment = <span class="hljs-keyword">new</span> Payment(id,<span class="hljs-string">"null"</span>);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CommonResult&lt;&gt;(<span class="hljs-number">444</span>,<span class="hljs-string">"兜底异常handlerFallback,exception内容  "</span>+e.getMessage(),payment);    &#125;      <span class="hljs-comment">//blockHandler</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult <span class="hljs-title">blockHandler</span><span class="hljs-params">(@PathVariable  Long id,BlockException blockException)</span> </span>&#123;        Payment payment = <span class="hljs-keyword">new</span> Payment(id,<span class="hljs-string">"null"</span>);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CommonResult&lt;&gt;(<span class="hljs-number">445</span>,<span class="hljs-string">"blockHandler-sentinel限流,无此流水: blockException  "</span>+blockException.getMessage(),payment);    &#125;&#125;</code></pre><p>ps:<strong style="color:red">若blockHandler和fallback都进行了配置，则被限流降级而抛出BlockException时只会进入blockHandler处理逻辑。</strong></p><p><strong>配置openfeign 业务</strong></p><pre><code class="hljs java"><span class="hljs-meta">@FeignClient</span>(value = <span class="hljs-string">"nacos-payment-provider"</span>,fallback = PaymentFallbackService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">interface</span> <span class="hljs-title">PaymentService</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-meta">@GetMapping</span>(value = <span class="hljs-string">"/paymentSQL/&#123;id&#125;"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult&lt;Payment&gt; <span class="hljs-title">paymentSQL</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> Long id)</span>;&#125;</code></pre><p><strong>实现类</strong>  </p><p>服务降级将返回次方法</p><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaymentFallbackService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">PaymentService</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult&lt;Payment&gt; <span class="hljs-title">paymentSQL</span><span class="hljs-params">(Long id)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CommonResult&lt;&gt;(<span class="hljs-number">44444</span>,<span class="hljs-string">"服务降级返回,---PaymentFallbackService"</span>,<span class="hljs-keyword">new</span> Payment(id,<span class="hljs-string">"errorSerial"</span>));    &#125;&#125;</code></pre><p>controller <strong>加入此方法</strong></p><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><span class="hljs-keyword">private</span> PaymentService paymentService;<span class="hljs-meta">@GetMapping</span>(value = <span class="hljs-string">"/consumer/paymentSQL/&#123;id&#125;"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult&lt;Payment&gt; <span class="hljs-title">paymentSQL</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> Long id) </span>&#123;    <span class="hljs-keyword">return</span> paymentService.paymentSQL(id);&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记/微服务/9-1-1springcloudAlibabaSentinel使用</title>
    <link href="/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/9-1-1springcloudAlibabaSentinel%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/9-1-1springcloudAlibabaSentinel%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="安装Sentinel"><a href="#安装Sentinel" class="headerlink" title="安装Sentinel"></a>安装Sentinel</h3><pre><code>**Sentienl 分为两个部分：**</code></pre><ul><li>核心库（java客户端）不依赖任何框架/库，能够运行于所有Java 运行时环境，同时对Dubbo/Spring Cloud 等框架也有较好的支持。</li><li>控制台（Dashboard）基于SpringBoot 开发，打包后可以直接运行，不需要额外的Tomcat等应用容器。</li></ul><h3 id="下载https-github-com-alibaba-Sentinel-releases"><a href="#下载https-github-com-alibaba-Sentinel-releases" class="headerlink" title="下载https://github.com/alibaba/Sentinel/releases"></a>下载<a href="https://github.com/alibaba/Sentinel/releases" target="_blank" rel="noopener">https://github.com/alibaba/Sentinel/releases</a></h3><p><img src="D:%5C%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE%5C%E5%8D%9A%E5%AE%A2%5Cimage-20201105220806333.png" srcset="/img/loading.gif" alt="image-20201105220806333"></p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>​    下载之后（有本地环境的情况下） 直接cmd </p><pre><code class="hljs java">java -jar xxx.jar</code></pre><p><strong style="color:red">默认占用的8080(跟tomcat一样)</strong></p><p>访问：localhost:8080  默认登录名密码都是 sentinel</p><p><img src="D:%5C%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE%5C%E5%8D%9A%E5%AE%A2%5Cimage-20201105221725250.png" srcset="/img/loading.gif" alt="image-20201105221725250"></p><h3 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h3><p><strong>pom</strong></p><pre><code class="hljs java">&lt;dependency&gt;     &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;     &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p><strong>YML</strong></p><pre><code class="hljs java">server:  port: <span class="hljs-number">8401</span>spring:  application:    name: cloudalibaba-sentinel-service  cloud:    nacos:      discovery:        server-addr: localhost:<span class="hljs-number">8848</span>    sentinel:      transport:        dashboard: localhost:<span class="hljs-number">8080</span>        port: 8719  #默认8719，假如被占用了会自动从8719开始依次+1扫描。直至找到未被占用的端口management:  endpoints:    web:      exposure:        include: <span class="hljs-string">'*'</span></code></pre><p><strong>启动类</strong></p><pre><code class="hljs java"><span class="hljs-meta">@EnableDiscoveryClient</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainApp8401</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(MainApp8401<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre><p><strong>controller</strong></p><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlowLimitController</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/testA"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testA</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"------testA"</span>;    &#125;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/testB"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testB</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"------testB"</span>;    &#125;&#125;</code></pre><p><strong>然后启动项目，在访问 sentinel 控制台（localhost:8080）</strong></p><p><strong>会发现什么都没有  : 由于Sentinel 采用的是懒加载机制，所以需要你自定义的方法先执行一次</strong></p><p><img src="D:%5C%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE%5C%E5%8D%9A%E5%AE%A2%5Cimage-20201105223514982.png" srcset="/img/loading.gif" alt="image-20201105223514982"></p><h3 id="流控规则"><a href="#流控规则" class="headerlink" title="流控规则"></a>流控规则</h3><p><img src="D:%5C%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE%5C%E5%8D%9A%E5%AE%A2%5Cimage-20201105223849585.png" srcset="/img/loading.gif" alt="image-20201105223849585"></p><p><strong style="color:red">说明:</strong></p><p><img src="D:%5C%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE%5C%E5%8D%9A%E5%AE%A2%5Cimage-20201105224205378.png" srcset="/img/loading.gif" alt="image-20201105224205378"></p><h4 id="流控模式"><a href="#流控模式" class="headerlink" title="流控模式"></a>流控模式</h4><p><strong>配置说明</strong></p><h5 id="直接"><a href="#直接" class="headerlink" title="直接"></a><strong>直接</strong></h5><p><img src="D:%5C%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE%5C%E5%8D%9A%E5%AE%A2%5Cimage-20201105224344408.png" srcset="/img/loading.gif" alt="image-20201105224344408"></p><p><strong>测试</strong></p><p>快速访问localhost:8401/testA (一秒内两次)</p><p>会发现浏览器会返回一个</p><p>​        <strong style="color:blue">Blocked by Sentinel (flow limiting)</strong></p><h5 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h5><p>当相关的的资源达到阈值值，就限流自己（比如：当与A 关联的资源B达到阈值的时候，就限流）</p><p><img src="D:%5C%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE%5C%E5%8D%9A%E5%AE%A2%5Cimage-20201106201910754.png" srcset="/img/loading.gif" alt="image-20201106201910754"></p><p><strong>测试</strong></p><p>可以使用 <strong style="color:blue">postman 或者 JMeter</strong> 等测试工具 并发密集的访问testB</p><p>同时访问 testA  然后你会发现A失效了</p><p>​    <strong style="color:blue">Blocked by Sentinel (flow limiting)</strong></p><h3 id="流控效果"><a href="#流控效果" class="headerlink" title="流控效果"></a>流控效果</h3><p><strong>快速失败</strong></p><p>​    直接失败，跑出异常。</p><p><strong>预热</strong></p><p>​    公式：<strong style="color:red">阈值除以coldFactor(默认值3)，经过预热时长后才会达到阈值</strong></p><p><img src="D:%5C%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE%5C%E5%8D%9A%E5%AE%A2%5Cimage-20201106235453597.png" srcset="/img/loading.gif" alt="image-20201106235453597"></p><p><strong>测试</strong></p><p>快速多次访问testB  刚开始不行</p><p><strong style="color:blue">应用场景: 秒杀系统之类的。在秒杀系统开启的瞬间，会有很多流量上来，很有可能把系统打死，预热方式就是为了保护系统，可慢慢的把流量放进来，慢慢的把阈值增长的设置的阈值</strong></p><h5 id="排队等待"><a href="#排队等待" class="headerlink" title="排队等待"></a>排队等待</h5><p>介绍：<strong style="color:red"> 均速排队，阈值必须设置为QPS</strong></p><p>匀速排队，让请求以均匀的速度通过。</p><p><img src="D:%5C%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE%5C%E5%8D%9A%E5%AE%A2%5Cimage-20201107000308042.png" srcset="/img/loading.gif" alt="image-20201107000308042"></p><h3 id="降级规则"><a href="#降级规则" class="headerlink" title="降级规则"></a>降级规则</h3><p>​    基本介绍：Sentinel熔断降级会在调用链路中某个资源出现不稳定状态时（(例如调用超时或异常比例升高)，对这个资源的调用进行限制，让请求快速失败，避免影响到其它的资源而导致级联错误。</p><p>当资源被降级后，在接下来的降级时间窗口之内，对该资源的调用都自动熔断（默认行为是抛出 DegradeException)。</p><p>ps:<strong style="color:red">Sentinel的断路器是没有半开状态的</strong></p><p>Hystrix：半开的状态系统自动去检测是否请求有异常，没有异常就关闭断路器恢复使用，有异常则继续打开断路器不可用</p><p><img src="D:%5C%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE%5C%E5%8D%9A%E5%AE%A2%5Cimage-20201107170445805.png" srcset="/img/loading.gif" alt="image-20201107170445805"></p><h5 id="RT"><a href="#RT" class="headerlink" title="RT"></a>RT</h5><p>​    介绍：平均响应时间：当1s内持续进入5个请求，对应时刻的平均响应时间 （秒）均超过阈值（count,以ms为单位）,那么在接下的时间窗口（DegradeRule中的timeWindow，以s为单位）之内，对这个方法的调用自动的熔断（抛出degradeException） <strong style="color:red">注意Sentinel默认统计的RT 上限是4900ms,超出此阈值的都会算作4900ms,若需要变更此上线可以通过启动配置项来-Dcsp.sentinel.statistic.max.rt=xxx配置</strong></p><p><img src="D:%5C%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE%5C%E5%8D%9A%E5%AE%A2%5Cimage-20201107173236342.png" srcset="/img/loading.gif" alt="image-20201107173236342"></p><p><strong>代码</strong></p><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/testD"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testD</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;    log.info(<span class="hljs-string">"testD 测试RT"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-string">"------testD"</span>;&#125;</code></pre><p><strong>配置</strong></p><p><img src="D:%5C%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE%5C%E5%8D%9A%E5%AE%A2%5Cimage-20201107173724194.png" srcset="/img/loading.gif" alt="image-20201107173724194"></p><p><strong>测试</strong></p><p>使用JMeter 进行测试一秒钟10个线程 发送请求；</p><p><strong>结论</strong></p><p>永远一秒钟打进来10个线程(大于5个了)调用testD，我们希望200毫秒处理完本次任务，<br>如果超过200毫秒还没处理完，在未来1秒钟的时间窗口内，断路器打开(保险丝跳闸)微服务不可用，保险丝跳闸断电了</p><p>后续我停止jmeter，没有这么大的访问量了，断路器关闭(保险丝恢复)，微服务恢复OK</p><h5 id="降级比列"><a href="#降级比列" class="headerlink" title="降级比列"></a>降级比列</h5><p>介绍：</p><p>异常比例(DEGRADE_GRADE_EXCEPTION_RATIo ):当资源的每秒请求量&gt;=5，并且每秒异常总数占<br>通过量的比值超过阈值（ DegradeRule中的count）之后，资源进入降级状态，即在接下的时<br>间窗口（ DegradeRule中的 timeWindow，以s为单位)之内，对这个方法的调用都会自动地返<br>回。异常比率的阈值范围是[0.0,1.0]，代表0%- 100%。</p><p><img src="D:%5C%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE%5C%E5%8D%9A%E5%AE%A2%5Cimage-20201107174332652.png" srcset="/img/loading.gif" alt="image-20201107174332652"></p><p><strong>代码</strong></p><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/testD"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testD</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        log.info(<span class="hljs-string">"testD 测试RT"</span>);        <span class="hljs-keyword">int</span> age = <span class="hljs-number">10</span>/<span class="hljs-number">0</span>;        <span class="hljs-keyword">return</span> <span class="hljs-string">"------testD"</span>;    &#125;</code></pre><p><strong>配置</strong></p><p><img src="D:%5C%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE%5C%E5%8D%9A%E5%AE%A2%5Cimage-20201107175535549.png" srcset="/img/loading.gif" alt="image-20201107175535549"></p><p><strong>测试</strong></p><p>使用JMeter 一秒钟 启动20个线程访问  TestD</p><p><strong>结论</strong></p><p><img src="D:%5C%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE%5C%E5%8D%9A%E5%AE%A2%5Cimage-20201107193828009.png" srcset="/img/loading.gif" alt="image-20201107193828009"></p><h5 id="异常数"><a href="#异常数" class="headerlink" title="异常数"></a>异常数</h5><p>介绍：</p><p>异常数(DEGRADE_GRADE_EXCEPTION_COUNT):当资源近1分钟的异常数目超过阈值之后会进行熔<br>断。注意由于统计时间窗口是分钟级别的，若timeWindow小于60s，则结束熔断状态后仍可能<br>再进入熔断状态。</p><p>ps：<strong style="color:red">异常数按分钟统计的</strong></p><p><img src="D:%5C%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE%5C%E5%8D%9A%E5%AE%A2%5Cimage-20201107194132086.png" srcset="/img/loading.gif" alt="image-20201107194132086"></p><p><strong>代码</strong></p><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/testE"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testE</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    log.info(<span class="hljs-string">"testE 测试异常数"</span>);    <span class="hljs-keyword">int</span> age = <span class="hljs-number">10</span>/<span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> <span class="hljs-string">"------testE 测试异常数"</span>;&#125;</code></pre><p><strong>配置</strong></p><p><img src="D:%5C%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE%5C%E5%8D%9A%E5%AE%A2%5Cimage-20201107194321613.png" srcset="/img/loading.gif" alt="image-20201107194321613"></p><h3 id="热点key限流"><a href="#热点key限流" class="headerlink" title="热点key限流"></a>热点key限流</h3><p>介绍：热点即经常访问的数据。很多时候我们希望统计某个热点数据中访问频次最高的 Top K 数据，并对其访问进行限制。比如：</p><ul><li>商品 ID 为参数，统计一段时间内最常购买的商品 ID 并进行限制</li><li>用户 ID 为参数，针对一段时间内频繁访问的用户 ID 进行限制</li></ul><p>热点参数限流会统计传入参数中的热点参数，并根据配置的限流阈值与模式，对包含热点参数的资源调用进行限流。热点参数限流可以看做是一种特殊的流量控制，仅对包含热点参数的资源调用生效。</p><p>Sentinel 利用 LRU 策略统计最近最常访问的热点参数，结合令牌桶算法来进行参数级别的流控。热点参数限流支持集群模式。</p><p><strong>代码</strong></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">* value 唯一 指定配置 </span><span class="hljs-comment">*blockHandler  指定兜底方法</span><span class="hljs-comment">**/</span><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/testHotKey"</span>)<span class="hljs-meta">@SentinelResource</span>(value = <span class="hljs-string">"testHotKey"</span>,blockHandler = <span class="hljs-string">"deal_testHotKey"</span>) <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testHotKey</span><span class="hljs-params">(@RequestParam(value = <span class="hljs-string">"p1"</span>,required = <span class="hljs-keyword">false</span>)</span> String p1,</span><span class="hljs-function">                         @<span class="hljs-title">RequestParam</span><span class="hljs-params">(value = <span class="hljs-string">"p2"</span>,required = <span class="hljs-keyword">false</span>)</span> String p2) </span>&#123;    <span class="hljs-comment">//int age = 10/0;</span>    <span class="hljs-keyword">return</span> <span class="hljs-string">"------testHotKey"</span>;&#125; <span class="hljs-comment">//兜底方法</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">deal_testHotKey</span> <span class="hljs-params">(String p1, String p2, BlockException exception)</span></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">"------deal_testHotKey,o(╥﹏╥)o"</span>;  &#125;</code></pre><p><strong>配置</strong></p><p><img src="D:%5C%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE%5C%E5%8D%9A%E5%AE%A2%5Cimage-20201107195441216.png" srcset="/img/loading.gif" alt="image-20201107195441216"></p><p>表示对第二个参数进行限流（默认是从0开始 ），一秒钟请求超过2次 就进行限流降级处理。</p><p><strong>测试</strong></p><p>访问testHostKey ,参数 p2=xxx ,  一秒钟访问10 次  发现会触发那个兜底方法 ， </p><p>而 传入 p1 =xxx ,p2不传 发现怎么也触发不了。 。</p><p><strong>特殊情况</strong></p><p><img src="D:%5C%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE%5C%E5%8D%9A%E5%AE%A2%5Cimage-20201107200850982.png" srcset="/img/loading.gif" alt="image-20201107200850982"></p><p>意思就是 p2 等于2 的 阈值超过3就 降级 。其他情况 要超过10 才降级限流</p><h3 id="系统规则"><a href="#系统规则" class="headerlink" title="系统规则"></a>系统规则</h3><p>介绍：</p><p>系统保护规则是从应用级别的入口流量进行控制，从单台机器的load、CPU使用率、平均RT、入口<br>QPS和并发线程数等几个维度监控应用指标，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳<br>定性。</p><p>系统保护规则是应用整体维度的，而不是资源维度的，并且仅对入口流量生效。入口流量指的是进入<br>应用的流量（EntryType.IN )，比如Web服务或Dubbo服务端接收的请求，都属于入口流量。</p><p><strong>系统规则支持以下的模式:</strong></p><ul><li>Load自适应(仅对Linux/Unix-like机器生效)∶系统的load1作为启发指标，进行自适应系统保护。当系统load1超过设定的启发值，且系统当前的并发线程数超过估算的系统容量时才会触保护。当系统load1超过设定的启发值，且系统当前的并发线程数超过估算的系统容量时才会触发系统保护（BBR阶段)。系统容量由系统的maxQps * minRt估算得出。设定参考值一般是CPU cores * 2.5。</li><li><strong>CPU usage(1.5.0+版本)</strong>︰当系统CPU使用率超过阈值即触发系统保护(取值范围0.0-1.0），比较灵敏。</li><li><strong>平均RT</strong>:当单台机器上所有入口流量的平均RT达到阈值即触发系统保护，单位是毫秒。</li><li><strong>并发线程数</strong>:当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护。</li><li><strong>入口QPS</strong>:当单台机器上所有入口流星的QPS达到阈值即触发系统保护。</li></ul><h3 id="sentinelResource"><a href="#sentinelResource" class="headerlink" title="@sentinelResource"></a>@sentinelResource</h3><p><strong>自定义限流处理逻辑</strong></p><p>自定义处理返回类</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsumerBlockHandler</span> </span>&#123;<span class="hljs-comment">// BlockException 必须 </span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CommonResult <span class="hljs-title">handlerException</span><span class="hljs-params">(BlockException e)</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CommonResult(<span class="hljs-number">200</span>,<span class="hljs-string">"自定义handler  global"</span>,<span class="hljs-keyword">new</span> Payment(<span class="hljs-number">2020L</span>,<span class="hljs-string">"202020"</span>));    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CommonResult <span class="hljs-title">handlerException2</span><span class="hljs-params">(BlockException e)</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CommonResult(<span class="hljs-number">200</span>,<span class="hljs-string">"自定义handler  global22"</span>,<span class="hljs-keyword">new</span> Payment(<span class="hljs-number">2020L</span>,<span class="hljs-string">"202020"</span>));    &#125;&#125;</code></pre><p><strong>新建Controller</strong></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">*blockHandlerClass  指定自定义兜底类</span><span class="hljs-comment">*blockHandler 指定自定义兜底方法（兜底类中）</span><span class="hljs-comment">**/</span><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/rateLimit/customerBlockHandler"</span>)<span class="hljs-meta">@SentinelResource</span>(value = <span class="hljs-string">"customerBlockHandler"</span>,        blockHandlerClass = CustomerBlockHandler<span class="hljs-class">.<span class="hljs-keyword">class</span>,</span><span class="hljs-class">        <span class="hljs-title">blockHandler</span> </span>= <span class="hljs-string">"handlerException2"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult <span class="hljs-title">customerBlockHandler</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CommonResult(<span class="hljs-number">200</span>,<span class="hljs-string">"按客戶自定义"</span>,<span class="hljs-keyword">new</span> Payment(<span class="hljs-number">2020L</span>,<span class="hljs-string">"serial003"</span>));&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记/微服务/9-1-0springcloudAlibabaSentinel 熔断跟 限流简介 </title>
    <link href="/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/9-1-0springcloudAlibabaSentinel%20%E7%86%94%E6%96%AD%E8%B7%9F%20%E9%99%90%E6%B5%81%E7%AE%80%E4%BB%8B%20/"/>
    <url>/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/9-1-0springcloudAlibabaSentinel%20%E7%86%94%E6%96%AD%E8%B7%9F%20%E9%99%90%E6%B5%81%E7%AE%80%E4%BB%8B%20/</url>
    
    <content type="html"><![CDATA[<h3 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h3><p>Sentinel 以流量为切入点，从流量控制，熔断降级，系统负载保护等多个维度保护服务的稳定性。</p><p>Sentinel 具有以下特征:</p><ul><li><strong>丰富的应用场景</strong>：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。</li><li><strong>完备的实时监控</strong>：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。</li><li><strong>广泛的开源生态</strong>：Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。</li><li><strong>完善的 SPI 扩展点</strong>：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。</li></ul><p><a href="https://github.com/alibaba/Sentinel/releases" target="_blank" rel="noopener">下载</a></p><h3 id="能干嘛"><a href="#能干嘛" class="headerlink" title="能干嘛"></a>能干嘛</h3><p><img src="D:%5C%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE%5C%E5%8D%9A%E5%AE%A2%5Cimage-20201105215606873.png" srcset="/img/loading.gif" alt="image-20201105215606873"></p><h3 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h3><ul><li>服务雪崩</li><li>服务降级</li><li>服务熔断</li><li>服务限流</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记/微服务/9-0-2springcloudAlibabaNacos 持久化（集群） </title>
    <link href="/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/9-0-2springcloudAlibabaNacos%20%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%88%E9%9B%86%E7%BE%A4%EF%BC%89%20/"/>
    <url>/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/9-0-2springcloudAlibabaNacos%20%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%88%E9%9B%86%E7%BE%A4%EF%BC%89%20/</url>
    
    <content type="html"><![CDATA[<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p><strong>默认Nacos使用嵌入式数据库（derby）实现数据的储存，所以如果启动多个默认配置的nacos节点，数据储存会存在一致性的问题</strong></p><p><strong>解决方案</strong>：<strong style="color:red">nacos采用了集中储存的方式来支持集群化部署，目前只支持mysql存储</strong></p><p><a href="https://nacos.io/zh-cn/docs/deployment.html" target="_blank" rel="noopener">文档</a></p><p><img src="D:%5C%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE%5C%E5%8D%9A%E5%AE%A2%5Cimage-20201018213644121.png" srcset="/img/loading.gif" alt="image-20201018213644121"></p><h3 id="从derby-切换mysql实现步骤"><a href="#从derby-切换mysql实现步骤" class="headerlink" title="从derby 切换mysql实现步骤"></a>从derby 切换mysql实现步骤</h3><ol><li><p>在nacos安装目录下 （nacos\conf\nacos-mysql.sql）找到sql脚本</p></li><li><p>然后在我们自己的数据库中执行脚本</p></li><li><p>最后在该目录下找到<strong style="color:red">application.properties</strong> 新增如下配置</p>  <pre><code class="hljs java">spring.datasource.platform=mysql <span class="hljs-comment">// 使用mysql</span>db.num=<span class="hljs-number">1</span>db.url<span class="hljs-number">.0</span>=jdbc:mysql:<span class="hljs-comment">//localhost:3306/nacos_devtest?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8&amp;rewriteBatchedStatements=true</span>db.user=rootdb.password=root</code></pre><p>  <strong style="color:red">目前配置mysql8.0 会出有问题（不建议 我使用的nacos1.1.4）</strong></p></li></ol><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>重启nacos ,可以看到一个全新的空记录界面，以前的记录都记录在Derby 中 </p><h3 id="部署集群"><a href="#部署集群" class="headerlink" title="部署集群"></a>部署集群</h3><p><strong>Linux版</strong></p><p>找到nacos 安装路劲中conf目录下的<strong style="color:red">cluster.conf.example</strong>,并重命名：<strong style="color:red"><strong style="color:red">cluster.conf</strong>  </p><p><img src="D:%5C%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE%5C%E5%8D%9A%E5%AE%A2%5Cimage-20201022210512422.png" srcset="/img/loading.gif" alt="image-20201022210512422"></p><p>在本机配置3台nacos，就配置三个端口</p><p><img src="D:%5C%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE%5C%E5%8D%9A%E5%AE%A2%5Cimage-20201022211324776.png" srcset="/img/loading.gif" alt="image-20201022211324776"></p><p><strong>配置nacos 的启动脚本：使它能接受不同的端口启动</strong> </p><p>找到nacos安装路劲的下的<strong>bin目录</strong>中的<strong style="color:red">startup.sh</strong></p><p><strong>修改内容：</strong></p><p><strong>在57行</strong></p><p><img src="D:%5C%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE%5C%E5%8D%9A%E5%AE%A2%5Cimage-20201022212748965.png" srcset="/img/loading.gif" alt="image-20201022212748965"></p><p><strong>其次倒数第二行</strong>：</p><p>修改前：</p><p><img src="D:%5C%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE%5C%E5%8D%9A%E5%AE%A2%5Cimage-20201022213052620.png" srcset="/img/loading.gif" alt="image-20201022213052620"></p><p>修改后</p><p><img src="D:%5C%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE%5C%E5%8D%9A%E5%AE%A2%5Cimage-20201022213213494.png" srcset="/img/loading.gif" alt="image-20201022213213494"></p><p><strong style="color:red">意思是：接受一个 -p 的指令 指定端口启动</strong></p><p>启动 ：</p><pre><code class="hljs shell">./startup.sh -p 3333./startup.sh -p 4444./startup.sh -p 5555</code></pre><p>Windows版：</p><p>复制三份 nacos 分别命为</p><p>nacos3333   nacos4444   nacos5555</p><p>修改conf目录下的<strong style="color:red">application.properties</strong></p><p><strong>改变端口号</strong></p><pre><code class="hljs java">server.port=<span class="hljs-number">3333</span>server.port=<span class="hljs-number">4444</span>server.port=<span class="hljs-number">5555</span></code></pre><p>ps：<strong style="color:red"> 是三个nacos的application.properties啊</strong></p><p>然后依次启动即可 </p><p>bin目录下的<strong style="color:red">startup.cmd</strong></p><h3 id="Nginx的配置作为负载均衡"><a href="#Nginx的配置作为负载均衡" class="headerlink" title="Nginx的配置作为负载均衡"></a>Nginx的配置作为负载均衡</h3><p><strong>修改nginx的配置文件： nginx 路劲的conf目录下的<strong style="color:red">nginx.conf</strong></strong>  </p><pre><code class="hljs shell">worker_processes  1;events &#123;    worker_connections  1024;&#125;http &#123;    include       mime.types;    default_type  application/octet-stream;    sendfile        on;    #keepalive_timeout  0;    keepalive_timeout  65;    #gzip  on;轮询    upstream cluster&#123;        server 127.0.0.1:3333;        server 127.0.0.1:4444;        server 127.0.0.1:5555;        &#125;    server &#123;        listen       1111;       server_name  localhost;        location / &#123;           # root   html;           # index  index.html index.htm;           proxy_pass http://cluster;        &#125;        #        error_page   500 502 503 504  /50x.html;        location = /50x.html &#123;            root   html;        &#125;    &#125;&#125;</code></pre><p><img src="D:%5C%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE%5C%E5%8D%9A%E5%AE%A2%5Cimage-20201022215241463.png" srcset="/img/loading.gif" alt="image-20201022215241463"></p><p><strong>然后启动nginx  在nginx路劲中sbin目录下</strong>  </p><pre><code class="hljs java">./nginx</code></pre><p>最后集群已配好  修改项目配置即可：</p><p><img src="D:%5C%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE%5C%E5%8D%9A%E5%AE%A2%5Cimage-20201022215916883.png" srcset="/img/loading.gif" alt="image-20201022215916883"></p><p>然后启动项目:  在访问 nginx 配置的地址 ：<a href="http://localhost:1111/nacos" target="_blank" rel="noopener">http://localhost:1111/nacos</a></p><p><img src="D:%5C%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE%5C%E5%8D%9A%E5%AE%A2%5Cimage-20201022221631201.png" srcset="/img/loading.gif" alt="image-20201022221631201"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记/微服务/9-0-1springcloudAlibabaNacos 使用</title>
    <link href="/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/9-0-1springcloudAlibabaNacos%20%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/9-0-1springcloudAlibabaNacos%20%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="安装并使用"><a href="#安装并使用" class="headerlink" title="安装并使用"></a>安装并使用</h3><p>本地要有java的环境 <strong>在去<a href="https://github.com/alibaba/nacos/releases" target="_blank" rel="noopener">下载</a></strong>，之后会得到一个压缩包</p><p><img src="D:%5C%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE%5C%E5%8D%9A%E5%AE%A2%5Cimage-20201018154049640.png" srcset="/img/loading.gif" alt="image-20201018154049640"></p><p>解压，在运行 <strong>bin下的startup.cmd</strong>  </p><p>如果环境什么的都没问题的话，直接访问 <a href="http://localhost:8848/nacos" target="_blank" rel="noopener">http://localhost:8848/nacos</a>  默认的账号密码都是<strong>nacos</strong></p><p><img src="D:%5C%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE%5C%E5%8D%9A%E5%AE%A2%5Cimage-20201018155701409.png" srcset="/img/loading.gif" alt="image-20201018155701409"></p><h3 id="建立Nacos提供者服务"><a href="#建立Nacos提供者服务" class="headerlink" title="建立Nacos提供者服务"></a><strong>建立Nacos提供者服务</strong></h3><p>pom</p><pre><code class="hljs java">&lt;dependency&gt;       &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;       &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;   &lt;/dependency&gt;</code></pre><p>YML</p><pre><code class="hljs java">server:port: <span class="hljs-number">9001</span>spring:  application:    name: nacos-provider-server  cloud:    nacos:      discovery:        server-addr: localhost:8848 #配置Nacos地址management:  endpoints:    web:      exposure:        include: <span class="hljs-string">'*'</span></code></pre><p>启动类</p><pre><code class="hljs java"><span class="hljs-meta">@EnableDiscoveryClient</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProvideMain9001</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(ProvideMain9001<span class="hljs-class">.<span class="hljs-keyword">class</span>,<span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre><p>controller</p><pre><code class="hljs javascript">@RestControllerpublic <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProvideController</span></span>&#123;        @Value(<span class="hljs-string">"$&#123;server.port&#125;"</span>)    private <span class="hljs-built_in">String</span> serverPort;        @GetMapping(<span class="hljs-string">"/provide/&#123;id&#125;"</span>)    public <span class="hljs-built_in">String</span> getProvideServer(@PathVariable Integer id)&#123;                <span class="hljs-keyword">return</span> <span class="hljs-string">"nacos provide  serverPort:"</span>+serverPort +<span class="hljs-string">"\t id:"</span>+id ;    &#125;&#125;</code></pre><p>启动该项目</p><p>访问 nacos 会发现  nacos-provider-server （nacos-payment-provide） 被注册进去了</p><p><img src="D:%5C%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE%5C%E5%8D%9A%E5%AE%A2%5Cimage-20201018164554266.png" srcset="/img/loading.gif" alt="image-20201018164554266"></p><h3 id="创建Nacos消费者服务"><a href="#创建Nacos消费者服务" class="headerlink" title="创建Nacos消费者服务"></a>创建Nacos消费者服务</h3><pre><code class="hljs java">&lt;!--SpringCloud ailibaba nacos --&gt;   &lt;dependency&gt;       &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;       &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;   &lt;/dependency&gt;</code></pre><p>YMl</p><pre><code class="hljs java">server:port: <span class="hljs-number">83</span>spring:  application:    name: nacos-consumer-server  cloud:    nacos:      discovery:        server-addr: localhost:<span class="hljs-number">8848</span># 自定义的service-url:  nacos-user-service: http:<span class="hljs-comment">//nacos-provider-server</span></code></pre><p>启动类</p><pre><code class="hljs java"><span class="hljs-meta">@EnableDiscoveryClient</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsumerMain83</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><span class="hljs-function">    </span>&#123;        SpringApplication.run(ConsumerMain83<span class="hljs-class">.<span class="hljs-keyword">class</span>,<span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre><p>config配置 （开启负载均衡 nacos 的内部包含来了 ribbon）</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApplicationContextConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@LoadBalanced</span>  <span class="hljs-comment">// 让RestTemplate  有负载均衡的能力</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">getRestTemplate</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();    &#125;;&#125;</code></pre><p>controller </p><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsumerController</span></span>&#123;        <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;service-url.nacos-user-service&#125;"</span>)    <span class="hljs-keyword">private</span> String serverUrl;        <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/consumer/&#123;id&#125;"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">consumerInfo</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> Integer id)</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.restTemplate.getForObject(<span class="hljs-keyword">this</span>.serverUrl+<span class="hljs-string">"/provide/"</span>+id,String<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    &#125;    &#125;</code></pre><p>启动该服务：</p><p>再次访问nacos      nacos-consumer-server（nacos-order-consumer）也注册进去了</p><p><img src="D:%5C%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE%5C%E5%8D%9A%E5%AE%A2%5Cimage-20201018174327410.png" srcset="/img/loading.gif" alt="image-20201018174327410"></p><p>我们现在可通过访问 消费端得到 服务端的内容了</p><p><a href="http://localhost:83/consumer/1" target="_blank" rel="noopener">http://localhost:83/consumer/1</a> </p><h3 id="nacos-配置中心"><a href="#nacos-配置中心" class="headerlink" title="nacos 配置中心"></a>nacos 配置中心</h3><p>pom</p><pre><code class="hljs java">&lt;!--nacos-config--&gt;  &lt;dependency&gt;      &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;      &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;  &lt;/dependency&gt;  &lt;dependency&gt;       &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;       &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;   &lt;/dependency&gt;</code></pre><p>YML (为什么有两个yml ? 因为 在项目初始化时，要保证先从配置中心配置拉取，项目才能正常启动) </p><p><strong style="color:red">bootstrap.yml 优先级高于 application.yml</strong></p><p><strong>bootstrap.yml</strong></p><pre><code class="hljs java">server:  port: <span class="hljs-number">3377</span>spring:  application:    name: nacos-config-client  cloud:    nacos:      discovery:        server-addr: localhost:8848 #nacos 服务注册中心地址      config:        server-addr: localhost:8848 #nacos 作为配置中心的地址        file-extension: yaml # z指定yaml格式配置</code></pre><p><strong>application.yml</strong></p><pre><code class="hljs java">spring:  profiles:    active: test</code></pre><p>启动类</p><pre><code class="hljs java"><span class="hljs-meta">@EnableDiscoveryClient</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NacosConfigClientMain3377</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(NacosConfigClientMain3377<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre><p>controller</p><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@RefreshScope</span>  <span class="hljs-comment">//  自动刷新</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConfigClientController</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;server.port&#125;"</span>)    <span class="hljs-keyword">private</span> String port;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;config.info&#125;"</span>) <span class="hljs-comment">//  从配置中心中读取的配置 </span>    <span class="hljs-keyword">private</span> String configInfo;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/getConfigInfo"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getConfigInfo</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"serverPort:"</span>+port+<span class="hljs-string">"\t"</span>+configInfo;    &#125;;&#125;</code></pre><p><strong>nacos 中添加配置信息</strong></p><p><strong style="color:red">nacos 中配置规则公式：</strong></p><pre><code class="hljs java">$&#123;spring.application.name&#125;-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</code></pre><p>ps：<strong style="color:red">服务名-当前环境.数据格式</strong></p><p><img src="D:%5C%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE%5C%E5%8D%9A%E5%AE%A2%5Cimage-20201018203857770.png" srcset="/img/loading.gif" alt="image-20201018203857770"></p><p><img src="D:%5C%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE%5C%E5%8D%9A%E5%AE%A2%5Cimage-20201018204431049.png" srcset="/img/loading.gif" alt="image-20201018204431049"></p><p><img src="D:%5C%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE%5C%E5%8D%9A%E5%AE%A2%5Cimage-20201018204606379.png" srcset="/img/loading.gif" alt="image-20201018204606379"></p><p>最后访问测试就好  <a href="http://localhost:3377/getConfigInfo" target="_blank" rel="noopener">http://localhost:3377/getConfigInfo</a></p><p>nacos <strong>分类配置</strong></p><p><img src="D:%5C%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE%5C%E5%8D%9A%E5%AE%A2%5Cimage-20201018210243055.png" srcset="/img/loading.gif" alt="image-20201018210243055"></p><p>Namespace+Group+Data ID 三者关系 。为什么这种设计</p><p><img src="D:%5C%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE%5C%E5%8D%9A%E5%AE%A2%5Cimage-20201018210528740.png" srcset="/img/loading.gif" alt="image-20201018210528740"></p><p><img src="D:%5C%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE%5C%E5%8D%9A%E5%AE%A2%5Cimage-20201018210757188.png" srcset="/img/loading.gif" alt="image-20201018210757188"></p><p>Group<strong>方案</strong></p><p><img src="D:%5C%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE%5C%E5%8D%9A%E5%AE%A2%5Cimage-20201018211657076.png" srcset="/img/loading.gif" alt="image-20201018211657076"></p><p><img src="D:%5C%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE%5C%E5%8D%9A%E5%AE%A2%5Cimage-20201018211750640.png" srcset="/img/loading.gif" alt="image-20201018211750640"></p><p>最后在bootstrap.yml 增加一条配置就好</p><p><img src="D:%5C%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE%5C%E5%8D%9A%E5%AE%A2%5Cimage-20201018211923590.png" srcset="/img/loading.gif" alt="image-20201018211923590"></p><p><strong>新建nameSpace</strong>  (test/dev)</p><p><img src="D:%5C%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE%5C%E5%8D%9A%E5%AE%A2%5Cimage-20201018212220778.png" srcset="/img/loading.gif" alt="image-20201018212220778"></p><p>然后去服务列表查看也可以去配置列表</p><p><img src="D:%5C%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE%5C%E5%8D%9A%E5%AE%A2%5Cimage-20201018212438998.png" srcset="/img/loading.gif" alt="image-20201018212438998"></p><p>再去bootstrap.yml  新增一条</p><p><img src="D:%5C%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE%5C%E5%8D%9A%E5%AE%A2%5Cimage-20201018212704827.png" srcset="/img/loading.gif" alt="image-20201018212704827"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记/微服务/9-0-0 springcloudAlibabaNacos 服务注册和配置中心 简介 </title>
    <link href="/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/9-0-0%20springcloudAlibabaNacos%20%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%92%8C%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%20%E7%AE%80%E4%BB%8B%20/"/>
    <url>/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/9-0-0%20springcloudAlibabaNacos%20%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%92%8C%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%20%E7%AE%80%E4%BB%8B%20/</url>
    
    <content type="html"><![CDATA[<h3 id="名字的由来（nacos）"><a href="#名字的由来（nacos）" class="headerlink" title="名字的由来（nacos）"></a>名字的由来（nacos）</h3><p>​    前四个字母 分别为Naming 和 configuration 的前两个字母，s 为Service</p><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><ul><li>​    一个更易于构建云原生应用的动态服务发现，配置管理和服务管理中心。</li><li>nacos 就是服务注册中心+ 配置中心的组合   nacos=Eureka+Config+Bus</li></ul><h3 id="能干嘛"><a href="#能干嘛" class="headerlink" title="能干嘛"></a>能干嘛</h3><p>​     替代Eureka做服务注册中心，替代Config做服务配置中心 </p><p><a href="https://github.com/alibaba/nacos/releases" target="_blank" rel="noopener">下载页面</a>   <a href="https://nacos.io/zh-cn/docs/quick-start.html" target="_blank" rel="noopener">官网文档</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记/微服务/8-0-1 springcloudSleuth 分布式链路使用</title>
    <link href="/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/8-0-1%20springcloudSleuth%20%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/8-0-1%20springcloudSleuth%20%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h3><p>​    Springcloud从F 版开始就不需要手动构建Zipkin server 了，只需要从<a href="https://dl.bintray.com/openzipkin/maven/io/zipkin/java/zipkin-server/" target="_blank" rel="noopener">官网</a> 下载jar就好。</p><p>然后在运行其jar包，访问 <a href="http://localhost:9411" target="_blank" rel="noopener">http://localhost:9411</a> 就可以访问其web页面</p><p>​    </p><p><strong>服务提供者：</strong></p><p>pom</p><pre><code class="hljs java">&lt;!--包含了sleuth+zipkin--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;        &lt;/dependency&gt;</code></pre><p>YML</p><pre><code class="hljs java">server:port: <span class="hljs-number">8081</span>spring:  application:    name: cloud-provide-service  zipkin:    base-url: http:<span class="hljs-comment">//localhost:9411</span>  sleuth:    sampler:    probability: 1 #采样率值介于0~1之间，1表示全部采集</code></pre><p>启动类</p><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> classs Application&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String [] args)</span></span>&#123;        SpringApplication.run(Application<span class="hljs-class">.<span class="hljs-keyword">class</span>,<span class="hljs-title">args</span>)</span>;    &#125; &#125;</code></pre><p>测试Controller</p><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProvideController</span> </span>&#123;        <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/provide/zipkin"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testZipkin</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello，zipkin"</span>;    &#125;&#125;</code></pre><p><strong>服务消费方：</strong></p><p>pom</p><pre><code class="hljs java">&lt;!--包含了sleuth+zipkin--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;        &lt;/dependency&gt;</code></pre><p>YML</p><pre><code class="hljs java">server:port: <span class="hljs-number">80</span>spring:  application:    name: cloud-test-service  zipkin:    base-url: http:<span class="hljs-comment">//localhost:9411</span>  sleuth:    sampler:    probability: 1 #采样率值介于0~1之间，1表示全部采集</code></pre><p>启动类</p><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> classs Application&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String [] args)</span></span>&#123;        SpringApplication.run(Application<span class="hljs-class">.<span class="hljs-keyword">class</span>,<span class="hljs-title">args</span>)</span>;    &#125; &#125;</code></pre><p>测试Controller 访问提供方</p><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestController</span></span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;        <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"test/zipkin"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testZipkin</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.restTemplate.getForObject(<span class="hljs-string">"http://localhost:8081/provide/zipkin"</span>, String<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    &#125;&#125;</code></pre><p>访问 <a href="http://localhost/test/zipkin" target="_blank" rel="noopener">http://localhost/test/zipkin</a>  测试。成功的话 页面会打印  <strong>hello，zipkin</strong></p><p>再去访问 <a href="http://localhost:9411" target="_blank" rel="noopener">http://localhost:9411</a> 访问zipkin页面 选择依赖 </p><p>会发现 之前发送的请求 的执行链路包括时间 </p><p>cloud-test-service ——–&gt; cloud-provide-service</p><p>执行原理：</p><p><img src="D:%5C%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE%5C%E5%8D%9A%E5%AE%A2%5Cimage-20201010173843565.png" srcset="/img/loading.gif" alt="image-20201010173843565"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记/微服务/8-0-0 springcloudSleuth分布式请求链路追踪 </title>
    <link href="/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/8-0-0%20springcloudSleuth%E5%88%86%E5%B8%83%E5%BC%8F%E8%AF%B7%E6%B1%82%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA%20/"/>
    <url>/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/8-0-0%20springcloudSleuth%E5%88%86%E5%B8%83%E5%BC%8F%E8%AF%B7%E6%B1%82%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA%20/</url>
    
    <content type="html"><![CDATA[<h3 id="是什么，干嘛的"><a href="#是什么，干嘛的" class="headerlink" title="是什么，干嘛的"></a>是什么，干嘛的</h3><p>​    <strong>解决的问题：</strong></p><p>​    在微服务框架 当中，一个由客户端的发起的请求在后端系统中会经过多个不同的服务节点调用，来协同产生最后的结果每一个前端请求都会形成一条复杂的分布式服务调用链路。链路中的任何一环出现高延时或错误都会引起整个请求最后的失败。</p><p><strong>是什么：</strong></p><p>​        SpringCloudSleuth提供一套完整的服务跟踪的解决方案 。</p><p>​        在分布式系统中提供追踪解决方案并兼容支持了zipkin(web页面展示)</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记/微服务/7-0-1 springcloudStream 使用</title>
    <link href="/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/7-0-1%20springcloudStream%20%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/7-0-1%20springcloudStream%20%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="新建消息驱动之生产者模块"><a href="#新建消息驱动之生产者模块" class="headerlink" title="新建消息驱动之生产者模块"></a>新建消息驱动之生产者模块</h3><p>pom</p><pre><code class="hljs java">&lt;dependency&gt;       &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;       &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt; &lt;/dependency&gt;</code></pre><p>YML</p><pre><code class="hljs java">server:  port: <span class="hljs-number">8801</span>spring:  application:    name: cloud-stream-provider  cloud:    stream:      binders: # 在此处配置要绑定的rabbitmq的服务信息；        defaultRabbit: # 表示定义的名称，用于于binding整合          type: rabbit # 消息组件类型          environment: # 设置rabbitmq的相关的环境配置            spring:              rabbitmq:                host: localhost                port: <span class="hljs-number">5672</span>                username: guest                password: guest      bindings: # 服务的整合处理        output: # 生产者          destination: studyExchange # 表示要使用的Exchange名称定义          content-type: application/json # 设置消息类型，本次为json，文本则设置“text/plain”          binder: defaultRabbit  # 设置要绑定的消息服务的具体设置</code></pre><p>启动类</p><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamMQMain8801</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(StreamMQMain8801<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre><p>业务类</p><pre><code class="hljs java"><span class="hljs-meta">@EnableBinding</span>(Source<span class="hljs-class">.<span class="hljs-keyword">class</span>) //定义消息的推送管道 <span class="hljs-title">Source</span> 生产者推送消息</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">MessageProviderImpl</span> </span><span class="hljs-class"></span>&#123;    <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> MessageChannel output; <span class="hljs-comment">// 消息发送管道</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">send</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        String serial = UUID.randomUUID().toString();        output.send(MessageBuilder.withPayload(serial).build());        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre><p>Controller</p><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SendMessageController</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> MessageProviderImpl messageProvider;    <span class="hljs-meta">@GetMapping</span>(value = <span class="hljs-string">"/sendMessage"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sendMessage</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">return</span> messageProvider.send();    &#125;&#125;</code></pre><h3 id="新建消息驱动之消费者模块"><a href="#新建消息驱动之消费者模块" class="headerlink" title="新建消息驱动之消费者模块"></a>新建消息驱动之消费者模块</h3><p>pom</p><pre><code class="hljs java">&lt;dependency&gt;      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;      &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>YML</p><pre><code class="hljs java">server:  port: <span class="hljs-number">8802</span>spring:  application:    name: cloud-stream-consumer  cloud:    stream:      binders: # 在此处配置要绑定的rabbitmq的服务信息；        defaultRabbit: # 表示定义的名称，用于于binding整合          type: rabbit # 消息组件类型          environment: # 设置rabbitmq的相关的环境配置            spring:              rabbitmq:                host: localhost                port: <span class="hljs-number">5672</span>                username: guest                password: guest      bindings: # 服务的整合处理        input: # 消费者          destination: studyExchange # 表示要使用的Exchange名称定义          content-type: application/json # 设置消息类型，本次为json，文本则设置“text/plain”          binder: defaultRabbit  # 设置要绑定的消息服务的具体设置</code></pre><p>启动类</p><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamMQMain8802</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(StreamMQMain8802<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre><p>Controller</p><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-meta">@EnableBinding</span>(Sink<span class="hljs-class">.<span class="hljs-keyword">class</span>) // <span class="hljs-title">Sink</span>  接收生产者推送的消息</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">ReceiveMessageListenerController</span> </span>&#123;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;server.port&#125;"</span>)    <span class="hljs-keyword">private</span> String serverPort;    <span class="hljs-meta">@StreamListener</span>(Sink.INPUT)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">input</span><span class="hljs-params">(Message&lt;String&gt; message)</span> </span>&#123;        System.out.println(<span class="hljs-string">"消费者1号，接受："</span>+message.getPayload()+<span class="hljs-string">"\t port:"</span>+serverPort);    &#125;&#125;</code></pre><p>测试 访问 <a href="http://localhost:8801/sendMessage" target="_blank" rel="noopener">http://localhost:8801/sendMessage</a>    8802 打印收到的信息</p><p>依照8802 消费者 在clone一份运行8803  然后启动</p><p>运行出现两个问题：</p><p><strong>1，重复消费情况：就是两个消费者 都收到了消息</strong></p><p><strong>2，消息持久化问题：就是两个消费者都没启动的情况，生产者发送消息，消费者接收不到</strong></p><p>原因：</p><p>两个消费者 不在同意分组下 所以都能接收到生产者推送的消息</p><p>解决方案：</p><p><strong style="color:red">分组和持久化属性group</strong></p><p><strong>在8802和8803的yml 文件中添加如下配置</strong></p><pre><code class="hljs java"><span class="hljs-comment">// 在spring.cloud.stream.bindings.input  新添配置:group: A</span>spring:cloud:stream:bindings:input:bindingsgroup: A</code></pre><p>ps: 配置了group 就算消费者在重启过程中也能接收到生产者推送的消息，避免了数据丢失</p><p><strong>注意 ：</strong></p><p>注意在Stream中处于同一个group中的多个消费者是竞争关系，就能够保证消息只会被其中一个应用消费一次。</p><p><strong style="color:red;font-size:20px">不同组是可以全面消费的(重复消费)，</strong><br><strong style="color:red;font-size:20px">同一组内会发生竞争关系，只有其中一个可以消费。</strong></p><h3 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h3><p>分布式微服务应用为了实现高可用和负载均衡，实际上都会部署多个实例。</p><p>多数情况下，生产者推送的消息给某个具体微服务时之希望被消费一次，按照上面的两个例子。虽然他们属于同一个应用，但是出现了被重复消费两次的情况，为了解决这个问题：</p><p><strong><strong style="color:red;">springcloudStream中提供了消费组的概念</strong></strong></p><p>8802和8803 实现了轮询分组，每次只有一个消费者可以接收8801 推送的消息。这样就避免了重复消费</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记/微服务/7-0-0 springcloudStream  消息驱动介绍</title>
    <link href="/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/7-0-0%20springcloudStream%20%20%E6%B6%88%E6%81%AF%E9%A9%B1%E5%8A%A8%E4%BB%8B%E7%BB%8D/"/>
    <url>/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/7-0-0%20springcloudStream%20%20%E6%B6%88%E6%81%AF%E9%A9%B1%E5%8A%A8%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p><strong>官方定义：是一个构建消息驱动微服务的框架</strong></p><ul><li>应用程序通过inputs（消费者）和outputs(生产者)来与 springcloudStream中的binder对象 交互。</li><li>通过配置来binding（绑定），而springcloudStream 的binder对象负责与消息中间件交互。</li><li>我们只需要搞清楚如何与springcloudStream交互就可以方便的使用消息驱动。</li></ul><p>通过使用Spring Integration来连接消息代理中间件以实现消息事件驱动。</p><p>SpringCloudStream 为一些供应商的消息中间件产品提供了个性化的自动配置实现，引用<strong style="color:red">发布-订阅，消费组，分区</strong>三大核心概念。</p><p>（一个系统可能存在多个消息中间件）</p><p>一句话概括：<strong style="color:red">屏蔽底层消息中间件的差异，降低切换成本，统一消息的编程模型</strong></p><p><strong style="color:red">目前仅支持RabbitMQ 和KafKa</strong></p><h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><p><strong>标准的MQ:</strong></p><ul><li>生产者/消费者之间 靠消息媒介传递信息内容</li><li>消息必须走特定的通道</li><li>消息通道里的消息如何被消费，谁负责处理？ 消息通道MessageChannel的子接口SubscribableChannel,由MessageHandler消息处理器订阅</li></ul><p><strong>springcloudStream：</strong></p><ul><li><p>​    统一底层差异：</p><p>   ​        在没有绑定器这个概念的情况下，我们的SpringBoot应用要直接与消息中间件进行信息交互的时候，</p><p>   ​        由于各消息中间件构建的初衷不同，它们的实现细节上会有较大的差异性<br>   ​        通过定义绑定器作为中间层，<strong style="color:red">完美地实现了应用程序与消息中间件细节之间的隔离。</strong></p><p>   ​        通过向应用程序暴露统一的Channel通道，使得应用程序不需要再考虑各种不同的消息中间件实现。</p><p>   ​    <strong><strong style="color:red;font-size:20px">通过定义绑定器Binded作为中间层，实现了应用程序与消息中间件细节之间的隔离。</strong></strong></p></li><li><p>Binder:</p><p>  ​        input(对应消费者)与output（对应生产者）</p></li><li><p>springcloudStream 中的消息通信方式遵循了 发布-订阅模式：</p><p>   ​            Topic主题进行广播 ： <strong><strong style="color:red">在RabbitMQ中就是Exchange ，在kafka中就是Topic</strong></strong></p></li></ul><pre><code>springcloudStream ：- binder ： 连接消息中间件，屏蔽差异- channel: 通道，是队列Queue 的一种抽象，在消息通讯系统中就是实现储存和转发的媒介，通过对channel队列进行配置。- Source和Sink : 简单理解为springcloudstream自身，发布消息就是输出，接受消息就是输入。​        </code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记/微服务/6-0-1 springcloudBus 使用 </title>
    <link href="/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/6-0-1%20springcloudBus%20%E4%BD%BF%E7%94%A8%20/"/>
    <url>/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/6-0-1%20springcloudBus%20%E4%BD%BF%E7%94%A8%20/</url>
    
    <content type="html"><![CDATA[<p>使用RabbitMq 就需要安装Erlang环境</p><p>然后在安装rabbitMq</p><p>启动管理功能：去 rabbitMq 安装目录下面找到<strong>sbin</strong>目录 ，进入cmd 输入：</p><p><strong>rabbimq-plugins enable rabbitmq_management</strong>  添加可视化插件</p><p>访问：localhost:15672 查询是否安装配置成功  默认账号guest 默认密码 guest</p><h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><ol><li>利用消息总线触发一个客户端/bus/refresh,从而刷新所有客户端的配置</li><li>利用消息总线触发一个服务端ConfigServer的/bus/refresh端点，从而刷新所有客户端配置（<strong>推荐</strong>）</li></ol><p>第二点的架构显然更加合适，第一点不合适原因 如下：</p><ul><li>打破了微服务的职责单一性，因为微服务本身是业务模块，它本不应该承担配置刷新职责</li><li>破坏微服务个节点的对等性</li><li>有一定的局限性，列如：微服务在迁移时，他的网咯地址常常会发生变化，此时如果想做到自动刷新，就要做更多的刷新。</li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><strong>pom</strong></p><p>在原来的springcloudConfig 的服务端和客户端加入如下：</p><pre><code class="hljs java">&lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p><strong>服务端application.yml</strong></p><pre><code class="hljs java">## rabbit 相关配置，暴露bus刷新配置的端口spring:    ## rabbitMq 相关配置  rabbitmq:    host: localhost    port: <span class="hljs-number">5672</span>    username: guest    password: guestmanagement:  endpoints:  #暴露bus刷新配置的端口    web:      exposure:        include: <span class="hljs-string">"bus-refresh"</span></code></pre><p>客户端bootstrap.yml</p><pre><code class="hljs java">spring:rabbitmq:        host: localhost        port: <span class="hljs-number">5672</span>        username: guest        password: guestmanagement:  endpoints:    web:      exposure:        include: <span class="hljs-string">"*"</span></code></pre><p>如果配置了多个微服务配置的话，</p><p>使用curl 发送这个请求给服务端，然后客户端向应的都会响应</p><pre><code class="hljs java">curl -X POST <span class="hljs-string">"http://localhost:8081/actuator/bus-refresh"</span></code></pre><p>ps:<strong>正所谓一次发送处处生效</strong></p><p>如果只想某一客户端生效的话就发送：</p><pre><code class="hljs java">curl -X POST <span class="hljs-string">"http://localhost:8081/actuator/bus-refresh/config-client:80"</span></code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记/微服务/6-0-0 springCloudBus 动态刷新介绍 </title>
    <link href="/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/6-0-0%20springCloudBus%20%E5%8A%A8%E6%80%81%E5%88%B7%E6%96%B0%E4%BB%8B%E7%BB%8D%20/"/>
    <url>/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/6-0-0%20springCloudBus%20%E5%8A%A8%E6%80%81%E5%88%B7%E6%96%B0%E4%BB%8B%E7%BB%8D%20/</url>
    
    <content type="html"><![CDATA[<p>作用：</p><p>实现对springcloudConfig 自动刷新配置功能</p><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p><strong>springcloudBus是用来将分布式系统的节点与轻量级消息系统链接起来的框架，</strong></p><p><strong style="color:red">它整合java的事件处理机制和消息中间件的功能</strong></p><p>springCloudBus目前支持RabbitMQ和Kafka</p><h3 id="能干嘛"><a href="#能干嘛" class="headerlink" title="能干嘛"></a>能干嘛</h3><p>springcloudBus能管理和传播分布式系统之间的消息，就像一个分布式执行器，可用于广播状态更改，事件推送等，也可以当作微服务间的通信通道</p><h3 id="什么是总线"><a href="#什么是总线" class="headerlink" title="什么是总线"></a>什么是总线</h3><p>在微服务架构的系统中，通常会使用<strong style="color:red">轻量级的消息代理</strong>来构建一个<strong style="color:red">共同的消息主题</strong>.并让系统中所有微服务实例都连接上来。由于<strong style="color:red">该主题中产生的消息会被所有实例监听和消费，所以称他为消息总线</strong>，在总线的各个实例，都可以方便的广播一些需要其他连接在该主题上的实例都知道 的消息</p><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>ConfigClient实例都监听MQ中同一个topic(默认是springCloudBus).当一个服务刷新数据的时候，他会把这个消息放入到Topic中，这样其他监听同一个Topic的服务就能得到通知，然后去更新自身的配置。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记/微服务/5-0-1 Config 使用</title>
    <link href="/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/5-0-1%20Config%20%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/5-0-1%20Config%20%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>在<strong>Github/码云</strong> 上 新建一个项目</p><p>clone 到本地 然后在该项目新建几个配置文件并提交（<strong><strong style="color:red">文件格式必须是utf-8格式的</strong></strong>）. 根据需要建。</p><pre><code class="hljs java">config-dev.ymlconfig-prod.ymlconfig-test.yml</code></pre><h3 id="项目中使用"><a href="#项目中使用" class="headerlink" title="项目中使用"></a>项目中使用</h3><p><strong>配置服务端</strong></p><p>pom文件</p><pre><code class="hljs java">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt; &lt;/dependency&gt;</code></pre><p>application.yml</p><pre><code class="hljs java">spring:  application:    name: cloud-config-center  cloud:    config:      server:        git:          uri:  https:<span class="hljs-comment">//github.com/weimao520/SpringCloudConfig.git  #配置中心地址</span>  search-paths:  # 搜索路劲            - spring-cloud-config      label: master # 分支</code></pre><p>启动类</p><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConfigCenterMain</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(ConfigCenterMain<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre><p>//  然后启动项目  master 分支 / config-dev.yml 文件名</p><p>访问 localhost:8081/master/config-dev.yml   就可以访问其GitHub配置信息</p><p><a href="http://localhost:8081/config/dev/master" target="_blank" rel="noopener">http://localhost:8081/config/dev/master</a>  这个也行，具体的请看官网</p><p><strong>编写客户端</strong></p><p><strong>pom</strong></p><p>相比较服务端 结尾少了  server</p><p><artifactId>spring-cloud-starter-config-server</artifactId></p><pre><code class="hljs java">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>bootstrap.yml</p><p>ps：<strong style="color:red">application.yml 是用户级资源配置项 bootstrap.yml 是系统级优先级更高</strong></p><pre><code class="hljs java">spring:  application:    name: config-clent  cloud:    config:      label: master      name: config  # 配置文件名称      profile: dev # 读取后缀名称  三个综合(label,name.profile)  在master分支上config-dev.yml的配置文件 地址是http://config-8081.com:3344/master/config      uri: http:<span class="hljs-comment">//localhost:8081 # 配置中心地址</span>## 要想实现动态配置 配置如下（就是更新GitHub上的配置文件，如果不配置的话需要重新启动该服务）management:  endpoints:    web:      exposure:        include: <span class="hljs-string">"*"</span></code></pre><p>启动类</p><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConfigClientMain80</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(ConfigClientMain80<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre><p><strong>测试访问 编写Controller</strong></p><pre><code class="hljs java"><span class="hljs-comment">//RefreshScope  动态刷新配置</span><span class="hljs-meta">@RestController</span><span class="hljs-meta">@RefreshScope</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConfigClientController</span> </span>&#123;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;config.info&#125;"</span>)    <span class="hljs-keyword">private</span> String configInfo;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/configInfo"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getConfigInfo</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.configInfo;    &#125;&#125;</code></pre><p>这样的话 还是不行 ；需要 访问 <a href="http://localhost/actuator/refresh" target="_blank" rel="noopener">http://localhost/actuator/refresh</a>   发送post 请求服务端的配置</p><p>我是使用curl</p><pre><code class="hljs java">curl -X POST <span class="hljs-string">"http://localhost/actuator/refresh"</span></code></pre><h3 id="存在-问题"><a href="#存在-问题" class="headerlink" title="存在 问题"></a>存在 问题</h3><p>如果配置多个微服务，每个服务都要执行一次post请求。</p><p>如何做到 一次通知。处处生效。(消息总线(Bus)) </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记/微服务/5-0-0 Config分布式中心介绍 </title>
    <link href="/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/5-0-0%20Config%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E5%BF%83%E4%BB%8B%E7%BB%8D%20/"/>
    <url>/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/5-0-0%20Config%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E5%BF%83%E4%BB%8B%E7%BB%8D%20/</url>
    
    <content type="html"><![CDATA[<h3 id="分布式面临的问题"><a href="#分布式面临的问题" class="headerlink" title="分布式面临的问题"></a>分布式面临的问题</h3><p>微服务意味着要将单体应用中的业务拆分成一个个子服务，每个服务的粒度相对较小，因此系统中会出现大量的服务。由于每个服务都需要必要的配置信息才能运行，所以一套集中式的、动态的配置管理设施是必不可少的。</p><p>（基本每个服务都带着<strong><strong style="color:red">application.yml</strong></strong>）</p><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>SpringCloudConfig为微服务架构中的微服务提供了一个集中式的外部配置 支持，配置服务器 为<strong style="color:red">各个不同微服务应用</strong>的所有环境<strong style="color:red">提供了一种中心化的外部配置</strong></p><h3 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h3><p>分为<strong><strong style="color:red">服务端和客户端</strong></strong>两部分</p><p>服务端也被称为<strong><strong style="color:red">分布式配置中心，他是独立的微服务应用</strong></strong>，用来连接配置服务器并为客户端提供获取配置信息，加密/解密信息等访问接口。</p><p>客户端则是指定配置中心来管理应用资源，以及与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息配置服务器。默认采用Git的来存储配置信息， 这样的话有助于对配置环境进行相关的版本管理，并且可以通过git客户端工具来方便的管理与访问配置内容。</p><h3 id="能干嘛"><a href="#能干嘛" class="headerlink" title="能干嘛"></a>能干嘛</h3><ul><li>能集中式管理配置文件</li><li>不同环境不同配置，动态化的配置更新，分环境部署如（dev/test/prod）.</li><li>运行期间动态调整配置，不在需要在每个服务部署的机器上编写配置文件，服务会向配置中心统一拉取配置自己的信息。</li><li>当配置发生改变时，服务不需要重新启动即可感知配置的变化并应用新的配置。</li><li>将配置信息一Rest接口的形式暴露 <strong style="color:red">ps: 使用curl   发送post请求刷新均可</strong></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记/微服务/4-0-1 网关gateway 使用</title>
    <link href="/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/4-0-1%20%E7%BD%91%E5%85%B3gateway%20%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/4-0-1%20%E7%BD%91%E5%85%B3gateway%20%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>pom</p><pre><code class="hljs java">&lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;        &lt;/dependency&gt;                &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;        &lt;/dependency&gt;</code></pre><p>application.yml</p><pre><code class="hljs java">spring:  application:    name: cloud-gateway  cloud:    gateway:      discovery:        locator:          enabled: true  #开启从注册中心动态创建路由功能，利用微服务名进行路由      routes:        - id: payment_routh #路由的ID，没有固定规则但要求唯一，建议配合服务名#          uri: http://localhost:8001   #匹配后提供服务的路由地址          uri: lb:<span class="hljs-comment">//CLOUD-PAYMENT-SERVICE   #利用微服务名进行动态路由 </span>          predicates:            - Path=/test/get<span class="hljs-comment">/**   #断言,路径相匹配的进行路由</span><span class="hljs-comment">            - Method=Get</span><span class="hljs-comment">#            - Cookie=username,hewei</span><span class="hljs-comment"></span><span class="hljs-comment">        - id: payment_routh2</span><span class="hljs-comment">#          uri: http://localhost:8001</span><span class="hljs-comment">          uri: lb://CLOUD-PAYMENT-SERVICE   #利用微服务名进行动态路由</span><span class="hljs-comment">          predicates:</span><span class="hljs-comment">            - Path=/test/lb/**   #断言,路径相匹配的进行路由</span></code></pre><p>启动器</p><pre><code class="hljs java"><span class="hljs-meta">@EnableEurekaClient</span><span class="hljs-meta">@EnableDiscoveryClient</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GatewayMain9527</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(GatewayMain9527<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre><p>ps： 现在在8001 外面套了一层9527 ，现在可以通过 访问9527 可以访问到8001 接口 这样就可以避免8001 对外暴露</p><p>如：</p><p>之前 <strong>location：8001/test/get/1</strong> </p><p>之后 <strong>localhost:9527/test/get/1</strong> </p><p>SpringCloud 配置网关的两种方式：</p><p>一种就是上面的配置的Yml 配置</p><p>还有一种就是写配置类</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GatewayConfig</span> </span>&#123;            <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RouteLocator <span class="hljs-title">routes</span><span class="hljs-params">(RouteLocatorBuilder builder)</span></span>&#123;        RouteLocatorBuilder.Builder build = builder.routes();        <span class="hljs-comment">//  访问 localhost：http://news.baidu.com/guonei" 就可以直接跳到该网站</span>        build.route( r -&gt; r.path(<span class="hljs-string">"/guonei"</span>). uri(<span class="hljs-string">"http://news.baidu.com/"</span>));        <span class="hljs-keyword">return</span> build.build();    &#125;&#125;</code></pre><h3 id="断言的介绍及使用"><a href="#断言的介绍及使用" class="headerlink" title="断言的介绍及使用"></a>断言的介绍及使用</h3><p>SpringcloudCateway将路由匹配作为Spring WebFlux HandlerMapping基础框架的一部分。</p><p>SpringCloudCateway包括许多内置的RouterPredicate工厂，所有这些Predicate都与HTTP请求不同属性相匹配。多个RouterPredicate工厂可以进行组合。</p><p>Spring Cloud Gateway创建Route对象时，使用RoutePredicateFactory创建Predicate对象，Predicate对象可以赋值给Route。Spring Cloud Gateway包含许多内置的Route Predicate Factories。</p><p>所有这些谓词都匹配HTTP请求的不同属性。多种谓词工厂可以组合，并通过逻辑and..</p><p><strong>使用：</strong></p><pre><code class="hljs java">spring:  application:    name: cloud-gateway  cloud:    gateway:      discovery:        locator:          enabled: true  #开启从注册中心动态创建路由功能，利用微服务名进行路由      routes:        - id: payment_routh #路由的ID，没有固定规则但要求唯一，建议配合服务名#          uri: http://localhost:8001   #匹配后提供服务的路由地址          uri: lb:<span class="hljs-comment">//CLOUD-PAYMENT-SERVICE   #利用微服务名进行动态路由</span>          predicates:            - Path=/payment<span class="hljs-comment">/**   #断言,路径相匹配的进行路由</span><span class="hljs-comment">            ## 2020-03-08。。 之后路由才起作用</span><span class="hljs-comment">            - After=2020-03-08T10:59:34.102+08:00[Asia/Shanghai]</span><span class="hljs-comment">            之后路由之前起作用</span><span class="hljs-comment">            - Before=2020-03-08T10:59:34.102+08:00[Asia/Shanghai]</span><span class="hljs-comment">            ###  两个时间之间</span><span class="hljs-comment">             - Between=2020-03-08T10:59:34.102+08:00[Asia/Shanghai] ,  2020-03-08T10:59:34.102+08:00[Asia/Shanghai]</span><span class="hljs-comment">             ##  设置请求方式</span><span class="hljs-comment">            - Method=Get</span><span class="hljs-comment">            ##  # 需要两个参数，一个Cookie name ,一个正则表达式</span><span class="hljs-comment">#            - Cookie=username,WeiMao</span><span class="hljs-comment">- Header=X-Request-Id, \d+   #请求头中要有X-Request-Id属性并且值为整数的正则表达式</span></code></pre><p>PS:*<em>Predicate 就是实现了一组匹配规则，让请求过来找到对应的Router进行处理 *</em></p><h3 id="过滤器（Filter）"><a href="#过滤器（Filter）" class="headerlink" title="过滤器（Filter）"></a>过滤器（Filter）</h3><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-meta">@Slf</span>4j<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyLogGateWayFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">GlobalFilter</span>,<span class="hljs-title">Ordered</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;        log.info(<span class="hljs-string">"*********come in MyLogGateWayFilter: "</span>+<span class="hljs-keyword">new</span> Date());        String uname = exchange.getRequest().getQueryParams().getFirst(<span class="hljs-string">"username"</span>);        <span class="hljs-keyword">if</span>(StringUtils.isEmpty(username))&#123;            log.info(<span class="hljs-string">"*****用户名为Null 非法用户,(┬＿┬)"</span>);            exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);<span class="hljs-comment">//给人家一个回应</span>            <span class="hljs-keyword">return</span> exchange.getResponse().setComplete();        &#125;        <span class="hljs-keyword">return</span> chain.filter(exchange);    &#125;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getOrder</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记/微服务/4-0-0  网关gateway 介绍</title>
    <link href="/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/4-0-0%20%20%E7%BD%91%E5%85%B3gateway%20%E4%BB%8B%E7%BB%8D/"/>
    <url>/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/4-0-0%20%20%E7%BD%91%E5%85%B3gateway%20%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p><strong>Gateway</strong>是在Spring生态系统之上构建的API网关服务，基于Spring5，SpringBoot 2 和Project Reactor等技术。</p><p><strong>Gateway</strong>皆在提供一种简单而有效的方式对API进行路由，以及提供一些强大的过滤器功能，如：熔断，限流，重试等 </p><p>SpringCloudGateway使用的Webflux的reactor-netty响应编程，底层使用Netty通讯框架</p><p>​            </p><h3 id="能干嘛"><a href="#能干嘛" class="headerlink" title="能干嘛"></a>能干嘛</h3><ul><li>反向代理</li><li>鉴权</li><li>流量控制</li><li>熔断</li><li>日志监控</li><li>等等等</li></ul><h3 id="为什么使用-SpringGateway"><a href="#为什么使用-SpringGateway" class="headerlink" title="为什么使用 SpringGateway"></a>为什么使用 SpringGateway</h3><p>一方面Zuul已进入维护阶段，zuul2 迟迟没有发布。</p><p>SpringCloudGateway 特性：</p><ul><li>基于Spring5，ProjectReator和SpringBoot2 进行构建。</li><li>动态路由：能够匹配任何请求属性。</li><li>可以对路由指定Predicate(断言)和Filter（过滤器）；</li><li>Hystrix的断路器功能</li><li>集成SpringCloud服务发现功能</li><li>易于编写Predicate(断言)和filter（过滤器）</li><li>请求限流功能</li><li>支持路劲重写</li></ul><p> <strong>Zuul 和 SpringCateway 区别</strong></p><ol><li>Zuul 1.x 是基于基于阻塞I/O 的Api cateway</li><li>Zuul1.x基于Servlet 2.5使用阻塞架构它不支持任何长连接(如WebSocket)Zuul的设计模式和Nginx较像，每次О操作都是从工作线程中选择一个执行，请求线程被阻塞到工作线程完成，但是差别是Nginx用C++实现，Zul用Java实现，而JVM本身会有第一次加载较慢的情况，使得Zuul的性能相对较差。</li><li>、Zuul 2.x（半成品）理念更先进，想基于Netty非阻塞和支持长连接，但SpringCloud目前还没有整合。</li><li>在性能方面，根据官方提供的基准测试，Spring Cloud Gateway的RPS(每秒请求数）是Zuul的1.6倍。</li><li>Spring Cloud Gateway建立在Spring Framework 5、Project Reactor和Spring Boot2之上，使用非阻塞API。</li><li>Spring Cloud Gateway还支持WebSocket，并且与Spring紧密集成拥有更好的开发体验</li></ol><h3 id="zuul-1-x模型"><a href="#zuul-1-x模型" class="headerlink" title="zuul 1.x模型"></a><strong>zuul 1.x模型</strong></h3><p>Springcloud中所集成的Zuul版本，采用的是Tomcat容器，使用的是传统的Servlet IO处理模型。</p><p><strong>Servlet的生命周期?servlet由servlet container进行生命周期管理</strong>。</p><p>container启动时构造servlet对象并调用servlet init()进行初始化;</p><p>container运行时接受请求，并为每个请求分配一个线程（一般从线程池中获取空闲线程）然后调用service()。</p><p>container关闭时调用servlet destory()销毁servlet;</p><p><strong style="color:red">上述模式的缺点</strong>:<br>servlet是一个简单的网络IO模型，当请求进入servlet container时，servlet container就会为其绑定一个线程，在<strong style="color:red">并发不高的场景</strong>下这种模型是适用的。但是一旦高并发(此如抽风用jemeter压)，线程数量就会上涨，而线程资源代价是昂贵的（上线文切换，内存消耗大)严重影响请求的处理时间。在一些简单业务场景下，不希望为每个request分配一个线程，只需要1个或几个线程就能应对极大并发的请求，这种业务场景下servlet摸型没有优势</p><p>所以Zuul1.X是基于servlet之上的一个阻塞式处理模型，即spring实现了处理所有request请求的一个servlet(DispatcherServlat)并由该sevlel阻塞塞式处理处理。所以Springcloud Zuul无法摆脱servlet模型的弊端</p><h3 id="springCloud模型"><a href="#springCloud模型" class="headerlink" title="springCloud模型"></a>springCloud模型</h3><p>基于<strong style="color:red">webflux</strong>之上实现的</p><p><strong>什么是webflux?</strong></p><p>传统的Web框架，比如说: struts2，springmvc等都是基于ServletAPl与Servlet容器基础之上运行的。但是</p><p><strong style="color:red">在Servlet3.1之后有了异步非阻塞的支持</strong>。而WebFlux是一个典型非阻塞异步的框架，它的核心是基于Reactor的相关API实现的。相对于传统的web框架来说，它可以运行在诸如Netty，Undertow及支持Servlet3.1的容器上。非阻塞式+函数式编程(Spring5必须让你使用java8)</p><p><strong>Spring WebFlux是Spring 5.0引入的新的响应式框架，区别于Spring MVC，它不需要依赖Servlet API，它是完全异步非阻塞的，并且基于Reactor来实现响应式流规范。</strong></p><h3 id="springCateway三大核心概念"><a href="#springCateway三大核心概念" class="headerlink" title="springCateway三大核心概念"></a>springCateway三大核心概念</h3><ul><li><strong style="color:red">Router(路由):</strong>路由是构建网关的基本模块，它由id，目标url，一系列的<strong style="color:blue">断言和过滤器组成</strong>，如果断言为true则配置该l路由 .</li><li><strong style="color:red">Predicate(断言):</strong> 如果请求与断言匹配则进行路由.</li><li><strong style="color:red">Filter(过滤器):</strong>指的是Spring框架中CatewayFilter的实例，使用过滤器，可以在请求被路由前或者之后对请求进行修改。</li></ul><p>PS: <strong>web请求，通过一些匹配条件，定位到真正的服务节点。并在这个转发过程的前后，进行一些精细化控制.<br>predicate就是我们的匹配条件;而fiter，就可以理解为一个无所不能的拦哉器。有了这两个元素，再加上目标uri，就可以实现一个具体的路由了</strong></p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>客户端向SpringcloudGateway发出请求，然后在GatewayHandlerMapping 中找到与请求行匹配的路由，将其发送到Gateway Web Handler.</p><p>Handler 在通过指定的过滤器来将请求发送到我们实际的服务执行业务逻辑，然后返回。</p><p>过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前（‘’pre”）或之后（‘’post“）执行业务逻辑。</p><p>Filter在 ‘’Pre“ 类型的过滤器可以做参数检验。权限校验，流量监控。日志输出。协议转换等。</p><p>在“Post”类型的过滤器中可以做响应内容，响应头的修改，日志的输出。流量监控等重要的作用。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记/微服务/3-0-5 断路器之Hystrix  监控测试 </title>
    <link href="/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/3-0-5%20%E6%96%AD%E8%B7%AF%E5%99%A8%E4%B9%8BHystrix%20%20%E7%9B%91%E6%8E%A7%E6%B5%8B%E8%AF%95%20/"/>
    <url>/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/3-0-5%20%E6%96%AD%E8%B7%AF%E5%99%A8%E4%B9%8BHystrix%20%20%E7%9B%91%E6%8E%A7%E6%B5%8B%E8%AF%95%20/</url>
    
    <content type="html"><![CDATA[<p><strong>pom</strong></p><pre><code class="hljs java">&lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt;        &lt;/dependency&gt;            <span class="hljs-comment">///  下面两个 需要图形化（web）显示的都加上为妙</span>        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;        &lt;/dependency&gt;</code></pre><p>application.yml </p><pre><code class="hljs java">## 配置端口号就好</code></pre><p><strong>启动类</strong></p><pre><code class="hljs java"><span class="hljs-meta">@EnableHystrixDashboard</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(Application<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre><p>​    <strong>然后直接根据配置的端口号加上 hystrix 访问就好如 （<a href="http://localhost:8080/hystrix）" target="_blank" rel="noopener">http://localhost:8080/hystrix）</a></strong></p><p>ps:<strong style="color:red">值得注意的的是由于springcloud的升级配被监控的服务（项目）要进行如下配置：</strong></p><pre><code class="hljs java">  <span class="hljs-comment">//在启动类下加上此方法</span><span class="hljs-comment">/**</span><span class="hljs-comment">     * 此配置是为了服务监控配置，与服务本身容错无关，springcloud 升级后的坑</span><span class="hljs-comment">     * ServletRegistrationBean 因为springboot的默认路劲不是‘/hystrix.stream’</span><span class="hljs-comment">     * 只要在自己的项目里配置一下Servlet 就行了</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ServletRegistrationBean <span class="hljs-title">getServlet</span><span class="hljs-params">()</span></span>&#123;        HystrixMetricsStreamServlet streamServlet = <span class="hljs-keyword">new</span> HystrixMetricsStreamServlet();        ServletRegistrationBean registrationBean = <span class="hljs-keyword">new</span> ServletRegistrationBean(streamServlet);        registrationBean.setLoadOnStartup(<span class="hljs-number">1</span>);        registrationBean.addUrlMappings(<span class="hljs-string">"/hystrix.stream"</span>);        registrationBean.setName(<span class="hljs-string">"HystrixMetricsStreamServlet"</span>);        <span class="hljs-keyword">return</span> registrationBean;    &#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记/微服务/3-0-4 断路器之Hystrix 熔断器说明</title>
    <link href="/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/3-0-4%20%E6%96%AD%E8%B7%AF%E5%99%A8%E4%B9%8BHystrix%20%E7%86%94%E6%96%AD%E5%99%A8%E8%AF%B4%E6%98%8E/"/>
    <url>/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/3-0-4%20%E6%96%AD%E8%B7%AF%E5%99%A8%E4%B9%8BHystrix%20%E7%86%94%E6%96%AD%E5%99%A8%E8%AF%B4%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<h3 id="断路器在什么时候起作用"><a href="#断路器在什么时候起作用" class="headerlink" title="断路器在什么时候起作用"></a>断路器在什么时候起作用</h3><p>涉及到断路器的三个重要参数:<strong style="color:red">快照时间窗、请求总数阀值、错误百分比阀</strong>值。</p><ul><li><p><strong style="color:red">快照时间窗:</strong>断路器确定是否打开需要统计一些请求和错误数据, 而统计的时间范围就是快照时间窗,默认为最近的10秒。</p></li><li><p><strong style="color:red">请求总数阀值:</strong>在快照时间窗内，必须满足请求总数阀值才有资格熔断。默认为20,意味着在10秒内,如果该hystrix命令的调用次数不足20次,即使所有的请求都超时或其他原因失败，断路器都不会打开。</p></li><li><p><strong style="color:red">错误百分比阀值:</strong>当请求总数在快照时间窗内超过了阀值,比如发生了30次调用,如果在这30次调用中,有1 5次发生了超时异常,也就是超过50%的错误百分比，在默认设定50%阀值情况下，这时候就会将断路器打开。</p></li></ul><h3 id="开启关闭的条件"><a href="#开启关闭的条件" class="headerlink" title="开启关闭的条件"></a>开启关闭的条件</h3><ul><li>当满足一定阈值的时候（默认10秒内超过20个请求数）</li><li>当失败率达到一定的时候（默认10内超50%的请求失败）</li><li>达到以上两点要求，断路器将会开启</li><li>当开启的时候，所有请求都不会进行转发</li><li>一段之后（默认5秒），断路器将会是半开状态，会让其中一个请求进行转发，如果成功，断路器关闭。如果失败，继续开启。周而复始</li></ul><h3 id="断路器打开之后"><a href="#断路器打开之后" class="headerlink" title="断路器打开之后"></a>断路器打开之后</h3><ul><li><p>再有请求调用的时候,将不会调用主逻辑，醍直接调用降级fallback。通过断路器，实现了自动地发现错误并将降级逻辑切换为主逻辑，减少响应延迟的效果。</p></li><li><p>原来的主逻辑要如何恢复呢?<br>   对于这- -问题，hystrix也为我们实现了 自动恢复功能。<br>   当断路器打开,对主逻辑进行熔断之后，hystrix会启动- 个休眠时间窗,在这个时间窗内,降级逻辑是临时的成为主逻辑,<br>   当休眠时间窗到期，断路器将进入半开状态,释放- -次请求到原来的主逻辑上,如果此次请求正常返回,那么断路器将继续闭合,<br>   主逻辑恢复,如果这次请求依然有问题，断路器继续进入打开状态,休眠时间窗重新计时。</p></li></ul><p>Hystrix <strong>所有配置</strong></p><pre><code class="hljs java">    <span class="hljs-meta">@HystrixCommand</span>(fallbackMethod = <span class="hljs-string">"str. _fallbackMethod"</span>,            groupKey = <span class="hljs-string">"strGroupCommand"</span>,            commandKey = <span class="hljs-string">"strCommarld"</span>,            threadPoolKey = <span class="hljs-string">"strThreadPool"</span>,            commandProperties = &#123;<span class="hljs-comment">//没置隔离策略，THREAD 表示线程他SEMAPHORE: 信号池隔离</span>                    <span class="hljs-meta">@HystrixProperty</span>(name = <span class="hljs-string">"execution. isolation. strategy"</span>, value = <span class="hljs-string">"THREAD"</span>),<span class="hljs-comment">//当隔离策峪选撣信号他隔离的时候，用来没置信号池的大小(最大并发数)</span>                    <span class="hljs-meta">@HystrixProperty</span>(name = <span class="hljs-string">"execution. isolation. semaphore . maxConcurrentRequests"</span>, value = <span class="hljs-string">"10"</span>),<span class="hljs-comment">//配置命令执行的超时时间</span>                    <span class="hljs-meta">@HystrixProperty</span>(name = <span class="hljs-string">"execution. isolation . thread . timeoutinMilliseconds"</span>, value = <span class="hljs-string">"10"</span>),<span class="hljs-comment">//是否启用超时时间</span>                    <span class="hljs-meta">@HystrixProperty</span>(name = <span class="hljs-string">"execution. timeout . enabled"</span>, value = <span class="hljs-string">"true"</span>),<span class="hljs-comment">//执行超时的时候是否中断</span>                    <span class="hljs-meta">@HystrixProperty</span>(name = <span class="hljs-string">"execution. isolation. thread . interruptOnTimeout"</span>, value = <span class="hljs-string">"true"</span>),<span class="hljs-comment">//执行被取消的时候是否中断</span>                    <span class="hljs-meta">@HystrixProperty</span>(name = <span class="hljs-string">" execution. isolation. thread . interrupt0nCancel"</span>, value = <span class="hljs-string">"true"</span>),<span class="hljs-comment">//允许回调方法执行的最大并发数</span>                    <span class="hljs-meta">@HystrixProperty</span>(name = <span class="hljs-string">"fallback. isolation. semaphore . maxConcurrentRequests"</span>, value = <span class="hljs-string">"10"</span>),<span class="hljs-comment">//服务降級是否启用，是否执行回调函数</span>                    <span class="hljs-meta">@HystrixProperty</span>(name = <span class="hljs-string">"fallback. enabled"</span>, value = <span class="hljs-string">"true"</span>),                    <span class="hljs-meta">@HystrixProperty</span>(name = <span class="hljs-string">"circuitBreaker . enabled"</span>, value = <span class="hljs-string">"true"</span>),                    <span class="hljs-comment">//该属性用来没置在壤动时间窗中，断路器熔断的最小请求数。例如，默认该值为20的时候，</span><span class="hljs-comment">//如果滚动时间窗(默以10秒)内仅收到了19个请求，即使这19 个请求都失败了，断路器也不会打开。</span>                    <span class="hljs-meta">@HystrixProperty</span>(name = <span class="hljs-string">"circuitBreaker . requestVolumeThreshold"</span>, value = <span class="hljs-string">"20"</span>),<span class="hljs-comment">//该属性用来没置在滚动时间窗中，表示在烧动时间窗中，在请求数量超过</span><span class="hljs-comment">// circuitBreaker. requestVoLumeThreshold的情况下，如果错误请求数的百分比超过50,</span><span class="hljs-comment">// 就把断路器设置为 ”打开”状态，否则就设置为 "关闭”状态。</span>                    <span class="hljs-meta">@HystrixProperty</span>(name = <span class="hljs-string">"circuitBreaker . errorThresholdPercentage"</span>, value = <span class="hljs-string">"50"</span>),<span class="hljs-comment">//该属性用来没置当断路器打开之后的休眠时间窗。休眠时间窗结束之后,</span><span class="hljs-comment">//会将断路器置为”半开”状态，尝试熔断的请求命令， 如果依然失败就将断路器继续没置为”打开”状态,</span><span class="hljs-comment">//如果成功就没置为"关闭”状态。</span>                    <span class="hljs-meta">@HystrixProperty</span>(name = <span class="hljs-string">"circuitBreaker . sleepWindowinMilliseconds"</span>, value = <span class="hljs-string">"5000"</span>),<span class="hljs-comment">//断路器强制打开</span>                    <span class="hljs-meta">@HystrixProperty</span>(name = <span class="hljs-string">" circuitBreaker . forceOpen"</span>, value = <span class="hljs-string">"false"</span>),<span class="hljs-comment">//断路器强制关闭</span>                    <span class="hljs-meta">@HystrixProperty</span>(name = <span class="hljs-string">" circuitBreaker . forceClosed"</span>, value = <span class="hljs-string">"false"</span>),<span class="hljs-comment">//滚动时间窗没置，该时间用于断路器判断健康度时需要收集信息的持续时间</span>                    <span class="hljs-meta">@HystrixProperty</span>(name = <span class="hljs-string">"metrics .rollingStats . timeinMilliseconds"</span>, value = <span class="hljs-string">"10000"</span>),<span class="hljs-comment">//该属性用来设置燎动时间窗统计指标信息时划分"桶"的数量，断路器在收集指标信息的时候会根据</span><span class="hljs-comment">//没置的时间窗长度拆分成多个”桶”来累计各度量值，每个” 桶"记录了-段时间内的来集指标。</span><span class="hljs-comment">//比如10秒内拆分成10个”桶"收集这样,所以timeinMilliseconds 必须能被numBuckets 整除。否则会抛异常</span>                    <span class="hljs-meta">@HystrixProperty</span>(name = <span class="hljs-string">"metrics . rollingStats . numBuckets"</span>, value = <span class="hljs-string">"10"</span>),                    <span class="hljs-comment">//滚动时间窗设置，该时间用于断路器判断健康度时需要收集信息的持续时间</span>                    <span class="hljs-meta">@HystrixProperty</span>(name = <span class="hljs-string">"metrics . rollingStats . timeinMilliseconds"</span>, value = <span class="hljs-string">"10000"</span>),<span class="hljs-comment">//该属性用来没置熾动时间窗统计指标信息时划分”桶"的数量，断路器在收集指标信息的时候会根据</span><span class="hljs-comment">//设置的时间窗长度拆分成多个”桶”来累计各度量值，每个”桶"记录了-段时间内的采集指标。</span><span class="hljs-comment">//比如10秒内拆分成10个”桶"收集这样，所以timeinMilliseconds 必须能被numBuckets 整除。否则会抛异常</span>                    <span class="hljs-meta">@HystrixProperty</span>(name = <span class="hljs-string">"metrics. rollingStats . numBuckets"</span>, value = <span class="hljs-string">"10"</span>),<span class="hljs-comment">//该属性用来没置对命令执行的延迟是否使用百分位数来跟踪和计算。如果没置为false,那么所有的概要统计都将返回-1。</span>                    <span class="hljs-meta">@HystrixProperty</span>(name = <span class="hljs-string">"metrics.rollingPercentile.enabled"</span>, value = <span class="hljs-string">"false"</span>),<span class="hljs-comment">//该属性用来没置百分位统i计的滚动窗口的持续时间，单位为亳秒。</span>                    <span class="hljs-meta">@HystrixProperty</span>(name = <span class="hljs-string">"metrics. rollingPercentile . timeInMilliseconds"</span>, value = <span class="hljs-string">"6000"</span>),<span class="hljs-comment">// 该属性用来没置百分位统计壤动窗口中使用“桶”的数量。</span>                    <span class="hljs-meta">@HystrixProperty</span>(name = <span class="hljs-string">"metrics . rollingPercentile. numBuckets"</span>, value = <span class="hljs-string">"60000"</span>),<span class="hljs-comment">//该属性用来没置在执行过程中每个 “桶” 中保留的最大执行次数。如果在滚动时间窗内发生超过该没定值的执行次数,</span><span class="hljs-comment">//就从最初的位置开始重写。例如，将该值没置为100，壤动窗口为10秒，若在10秒内一个“桶 ”中发生了500次执行，</span>                    <span class="hljs-comment">//那么该“桶”中只保留最后的100次执行的统计。另外，增加该值的大小将会增加内存量的消耗，并增加排序百分位数所需的计算时间。</span>                    <span class="hljs-meta">@HystrixProperty</span>(name = <span class="hljs-string">"metrics. rollingPercentile . bucketSize"</span>, value = <span class="hljs-string">"100"</span>),<span class="hljs-comment">//该属性用来没置采集影响断路器状态的健康快照(请求的成功、错误百分比) 的间隔等待时间。</span>                    <span class="hljs-meta">@HystrixProperty</span>(name = <span class="hljs-string">"metrics. healthSnapshot . intervalinMilliseconds"</span>, value = <span class="hljs-string">"500"</span>),<span class="hljs-comment">//是否开启请求缓存</span>                    <span class="hljs-meta">@HystrixProperty</span>(name = <span class="hljs-string">" requestCache . enabled"</span>, value = <span class="hljs-string">"true"</span>),<span class="hljs-comment">// HystrixCommand的执行和事件是否打印日志到HystrixRequestLog中</span>                    <span class="hljs-meta">@HystrixProperty</span>(name = <span class="hljs-string">"requestLog.enabled"</span>, value = <span class="hljs-string">"true"</span>),                    <span class="hljs-meta">@HystrixProperty</span>(name = <span class="hljs-string">"metrics. rollingPercentile . bucketSize"</span>, value = <span class="hljs-string">"100"</span>),<span class="hljs-comment">//该属性用来没置采集影响断路器状态的健康快照(请求的成功、错误百分比)的间隔等待时间。</span>                    <span class="hljs-meta">@HystrixProperty</span>(name = <span class="hljs-string">"metrics . healthSnapshot . intervalinMilliseconds"</span>, value = <span class="hljs-string">"500"</span>),<span class="hljs-comment">//是否开启请求缓存</span>                    <span class="hljs-meta">@HystrixProperty</span>(name = <span class="hljs-string">"requestCache .enabled"</span>, value = <span class="hljs-string">"true"</span>),<span class="hljs-comment">// HystrixCommand的执行和事件是否打印日志到HystrixRequestLog中</span>                    <span class="hljs-meta">@HystrixProperty</span>(name = <span class="hljs-string">" requestLog. enabled"</span>, value = <span class="hljs-string">"true"</span>),            &#125;,            threadPoolProperties = &#123;<span class="hljs-comment">//该参数用来没置执行命令线程池的核心线程数， 该值也就是命令执行的最大并发量</span>                    <span class="hljs-meta">@HystrixProperty</span>(name = <span class="hljs-string">"coreSize"</span>, value = <span class="hljs-string">"10"</span>),<span class="hljs-comment">//该参数用来没置线程地的最大队列大小。当没置为-1时，线程池将使用SynchronousQueue 实现的队列,</span><span class="hljs-comment">//否则将使用LinkedBlockingQueue 实现的队列。</span>                    <span class="hljs-meta">@HystrixProperty</span>(name = <span class="hljs-string">"maxQueueSize"</span>, value = <span class="hljs-string">"-1"</span>),<span class="hljs-comment">//该参数用来为队列没置拒绝阙值。通过该参数，即使队列没 有达到最大值也能拒绝请求。</span><span class="hljs-comment">//该参数主要是对LinkedBlockingQueue队列的补充,因为LinkedBlockingQueue</span><span class="hljs-comment">//队列不能动态修改它的对象大小，而通过该属性就可以调整拒绝请求的队列大小了。</span>                    <span class="hljs-meta">@HystrixProperty</span>(name = <span class="hljs-string">"queueSizeRejectionThreshold"</span>, value = <span class="hljs-string">"5"</span>),&#125;)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">strConsumer</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"he1lo 2020"</span>;    &#125;</code></pre><h3 id="Hystrix执行流程"><a href="#Hystrix执行流程" class="headerlink" title="Hystrix执行流程"></a>Hystrix执行流程</h3><ol><li><p>创建HystrixCommand (用在依赖的服务返回单个操作结果的时候)或HystrixObserableCommand (用在依赖的服务返回多个操作结果的时候)对象。</p></li><li><p>命令执行。其中HystrixComand实现了下面前两种执行方式:而HystrixObservableCommand实现了后两种执行方式: execute0: 同步执行，从依赖的服务返回一个单-的结果对象，或是在发生错误的时候抛出异常。queue0: 异步执行，直接返回 -个Future对象，其中包含 了服务执行结束时要返回的单一结果对象。 observe0: 返回Observable对象，它代表了操作的多个结果,它是一个Hot Obserable (不论事件源”是否有“订阅者”.都会在创建后对事件进行发布,所以对于Hot Observable的每-个“订阅者”都有可能是从°事件源”的中途开始的.并可能只是看到了整个操作的局部过程) . toObservable0: 同样会返回Observable对象，也代表了操作的多个结果,但它返回的是一个Cold Observable (没有“订阅者”的时候并不会发布事件.而是进行等待.直到有“订阅者”之后才发布事件,所以对于Cold Observable的订阅者,它可以保证从-开始看到整个操作的全部过程) .</p></li><li><p>若当前命令的请求缓存功能是被启用的，并且该命令缓存命中， 那么缓存的结果会立即以 Observable对象的形式返回。</p></li><li><p>检查断路器是否为打开状态。如果断路器是打开的，那么Hytix不会执行令,而是转接到flback处理逻辑(第8步) :如果断路器是关闭的，检查是否有可用资源来执行命令(第5步) .</p></li><li><p>| 线程池/请求队列/信号量是否占满。如果命令依赖服务的专有线程地和请求队列.或者信号量(不使用线程地的时候)已经被占满， 那么Hystix也不会执行命令。 而是转接到fllback处理逻辑(第8步）</p></li><li><p>Hystrix 会根据我们编写的方法来决定采取什么样的方式去请求依赖服务。HystrixCommand.run0 :返回-一个单-的结果, 或者抛出异常。HystrixObservableCommand.construct0: 返回一个Observable对象来发射多个结果.或通过onError发送错误通知。</p></li><li><p>| Hystrix会将“成功”、 “失败”、 “拒绝”、 “超时“等信息报告治断路器，而断路器会维护- 组计数嚣来统计这些数据。断路器会使用这些统计数据来决定是否要将断路器打开.来对某个依赖服务的请求进行“焰断/短路”.</p></li><li><p>当命令执行失败的时候，Hystrix 会进入flback尝试回退处理，我们通常也称该操作为 ”服务降级”.而能够引起服务降级处理的情况有下面几种:第4步:当前命令处于 “熔断/短路“状态.断路器是打开的时候。第5步:当前命令的线程池、 请求队列或 者信号量被占满的时候。第6步: HystrixObservableCommand.construct0) 或HystrixCommand.run0抛出异常的时候。</p></li><li><p>当Hystrix命令执行成功之后，它会将处理结果直接返回或是以Observable 的形式返回。</p></li></ol><pre><code>**&lt;strong style=&quot;color:red&quot;&gt;tips:&lt;/strong&gt;**如果我们没有为命令实现降级逻辑或者在降级处理逻辑中抛出了异常，Hystix 依然会返回一个Observable对象，但是它不会发射任何结果数据，而是通过onError方法通知命令立即中断请求.并通过onError(方法将引起命令失败的异常发送给调用者.</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记/微服务/3-0-3 断路器之Hystrix 熔断器使用</title>
    <link href="/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/3-0-3%20%E6%96%AD%E8%B7%AF%E5%99%A8%E4%B9%8BHystrix%20%E7%86%94%E6%96%AD%E5%99%A8%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/3-0-3%20%E6%96%AD%E8%B7%AF%E5%99%A8%E4%B9%8BHystrix%20%E7%86%94%E6%96%AD%E5%99%A8%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>使用  :</p><p><strong>service层</strong></p><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Service</span></span>&#123;                <span class="hljs-meta">@HystrixCommand</span>(fallbackMethod = <span class="hljs-string">"breaker_fallback"</span>,commandProperties = &#123;            <span class="hljs-meta">@HystrixProperty</span>(name=<span class="hljs-string">"circuitBreaker.enabled"</span>,value = <span class="hljs-string">"true"</span>),<span class="hljs-comment">// //是否开启断路器</span>            <span class="hljs-meta">@HystrixProperty</span>(name = <span class="hljs-string">"circuitBreaker.requestVolumeThreshold"</span>,value = <span class="hljs-string">"10"</span>),   <span class="hljs-comment">//请求次数</span>            <span class="hljs-meta">@HystrixProperty</span>(name = <span class="hljs-string">"circuitBreaker.sleepWindowInMilliseconds"</span>,value = <span class="hljs-string">"10000"</span>),  <span class="hljs-comment">//时间范围</span>            <span class="hljs-meta">@HystrixProperty</span>(name = <span class="hljs-string">"circuitBreaker.errorThresholdPercentage"</span>,value = <span class="hljs-string">"60"</span>), <span class="hljs-comment">//失败率达到多少后跳闸</span>    &#125;)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">circuitBreaker</span><span class="hljs-params">(Integer id)</span> </span>&#123;        <span class="hljs-keyword">if</span> (id &lt;= <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">throw</span>  <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"出错啦"</span>);        &#125;        String s = IdUtil.simpleUUID();        <span class="hljs-keyword">return</span> s+<span class="hljs-string">"访问"</span><span class="hljs-string">"OK咯"</span>;    &#125;         <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">breaker_fallback</span><span class="hljs-params">(Integer id)</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"id 不能负数，请稍候再试,(┬＿┬)/~~     id: "</span> +id;    &#125;&#125;</code></pre><p><strong>controller层</strong></p><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestController</span></span>&#123;          <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> Service service;        <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/circuit/&#123;id&#125;"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">circuitBreaker</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> Integer id)</span>&#123;        String result = service.circuitBreaker(id);        log.info(<span class="hljs-string">"*******result:"</span>+result);        <span class="hljs-keyword">return</span> result;    &#125;  &#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记/微服务/3-0-2 断路器之Hystrix 熔断器简介 </title>
    <link href="/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/3-0-2%20%E6%96%AD%E8%B7%AF%E5%99%A8%E4%B9%8BHystrix%20%E7%86%94%E6%96%AD%E5%99%A8%E7%AE%80%E4%BB%8B%20/"/>
    <url>/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/3-0-2%20%E6%96%AD%E8%B7%AF%E5%99%A8%E4%B9%8BHystrix%20%E7%86%94%E6%96%AD%E5%99%A8%E7%AE%80%E4%BB%8B%20/</url>
    
    <content type="html"><![CDATA[<h3 id="熔断器"><a href="#熔断器" class="headerlink" title="熔断器"></a>熔断器</h3><p><strong>熔断是什么</strong></p><p>熔断机制概述：</p><p>熔断机制是应对雪崩效应的一种微服务链路保护机制。当扇出链路的某个微服务出错不可用或者响应时间太长时,会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。<br><strong style="color:red">当检测到该节点微服务调用响应正常后，恢复调用链路。</strong></p><p>在Spring Cloud框架里，熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状况,<br>当失败的调用到一定阈值，缺省是5秒内20次调用失败，就会启动熔断机制。熔断机制的注解是@HystrixCommand.</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记/微服务/3-0-1 断路器之 Hystrix 服务降级使用</title>
    <link href="/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/3-0-1%20%E6%96%AD%E8%B7%AF%E5%99%A8%E4%B9%8B%20Hystrix%20%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/3-0-1%20%E6%96%AD%E8%B7%AF%E5%99%A8%E4%B9%8B%20Hystrix%20%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="Hystrix-服务降级"><a href="#Hystrix-服务降级" class="headerlink" title="Hystrix  服务降级"></a>Hystrix  服务降级</h3><p>—简单使用</p><p><strong>Pom</strong></p><pre><code class="hljs java"><span class="hljs-comment">// 其他的省略 。。。</span>&lt;!--新增hystrix--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;        &lt;/dependency&gt;</code></pre><p><strong>application.yml</strong></p><pre><code class="hljs java"><span class="hljs-comment">// hystrix 不用配置  其他的该配的配 如：server.port:8080</span></code></pre><p><strong>启动类</strong></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> *启动断路器</span><span class="hljs-comment"> */</span><span class="hljs-meta">@EnableCircuitBreaker</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(Application<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre><p><strong>service层</strong></p><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestService</span></span>&#123;        <span class="hljs-comment">/**</span><span class="hljs-comment">     *fallbackMethod 指定回退的方法(出错就会调用它指定的方法)</span><span class="hljs-comment">     * commandProperties 配置hystrix命令的参数  以下表示 此方法响应时间超过 3秒 表示超时</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@HystrixCommand</span>(fallbackMethod = <span class="hljs-string">"timeOutHandler"</span>,commandProperties = &#123;            <span class="hljs-meta">@HystrixProperty</span>(name = <span class="hljs-string">"execution.isolation.thread.timeoutInMilliseconds"</span>,value = <span class="hljs-string">"3000"</span>)    &#125;)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">timeOutMethod</span><span class="hljs-params">(Integer id)</span> </span>&#123;        <span class="hljs-keyword">int</span> timeOut = <span class="hljs-number">5</span>;        <span class="hljs-keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(timeOut);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;              <span class="hljs-keyword">return</span> <span class="hljs-string">"线程池  "</span>+Thread.currentThread().getName()+<span class="hljs-string">" payment_tiemOut  "</span>+id+<span class="hljs-string">"---------------超时了"</span>;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> String  <span class="hljs-title">timeOutHandler</span><span class="hljs-params">(Integer id)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"线程池  "</span>+Thread.currentThread().getName()+<span class="hljs-string">" tiemOut  "</span>+id+<span class="hljs-string">"-----------o(π——π)o----我是超时的回调"</span>;    &#125;&#125;</code></pre><p><strong>controller层</strong></p><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@Slf</span>4j<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestController</span></span>&#123;        <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> TestService testService;         <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"test/timeout/&#123;id&#125;"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">timeOut</span><span class="hljs-params">(@PathVariable Integer id)</span> </span>&#123;        <span class="hljs-keyword">return</span>   <span class="hljs-keyword">this</span>.testService.timeOutMethod(id);    &#125;&#125;</code></pre><p>—进阶版 配合 <strong><strong style="color:red">openFeign</strong></strong></p><p><strong>pom</strong></p><pre><code class="hljs java">&lt;!--新增hystrix--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p><strong>application.yml</strong></p><pre><code class="hljs java">   # 设置feign客户端超时时间（openFeign 默认支持ribbon）ribbon:  #指建立连接所用的时间，适用网咯状况正常的情况下，两端所用的时间  ReadTimeout:  <span class="hljs-number">5000</span>  #  指建立连接后从服务器读取到可用资源的时间  ConnectTimeout: <span class="hljs-number">5000</span># openFeign  启动 Hystrix      feign:  hystrix:    enabled: <span class="hljs-keyword">true</span></code></pre><p>​    </p><p><strong>启动类</strong></p><pre><code class="hljs java"><span class="hljs-meta">@EnableHystrix</span><span class="hljs-meta">@EnableFeignClients</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(OrderHystrixMain80<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre><p><strong>Service</strong></p><pre><code class="hljs less"><span class="hljs-comment">/**</span><span class="hljs-comment"> *name（name 或者value 必须） 如果配置了注册中心的话就指定其中微服务名称，没有就取一个跟项目相关的，他会找URL 指定的地址</span><span class="hljs-comment"> *   url  指定请求的Api地址 （非必须）</span><span class="hljs-comment"> *  fallback 指定回退的类</span><span class="hljs-comment"> * @author WeiMao</span><span class="hljs-comment"> * @create 2020-08-26 21:49</span><span class="hljs-comment"> */</span><span class="hljs-variable">@FeignClient</span>(name = <span class="hljs-string">"ss"</span>,url=<span class="hljs-string">"localhost:8001"</span>,fallback = FallbackService.class)<span class="hljs-variable">@Component</span>public interface Service &#123;    <span class="hljs-variable">@GetMapping</span>(<span class="hljs-string">"test/timeout/&#123;id&#125;"</span>)    String timeOut(<span class="hljs-variable">@PathVariable</span>(<span class="hljs-string">"id"</span>) Integer id);&#125;</code></pre><p>​    <strong>Fallback类</strong></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">*继承Feign 接口 实现其中的方法 如果方法出异常就会回退（服务降级）返回出去</span><span class="hljs-comment">*/</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FallbackService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Service</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">timeOut</span><span class="hljs-params">(Integer id)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"FallbackService 类中 timeOut 方法 我超时了 o(╥﹏╥)o Ծ‸Ծ"</span>;    &#125;&#125;</code></pre><p><strong>Controller</strong></p><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> WeiMao</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-08-26 21:50</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Slf4j</span><span class="hljs-meta">@RestController</span><span class="hljs-comment">//全局出错指定提示信息方法（服务降级） 如果没有单独给方法配置，发生异常的话就会回退进入全局的方法当中</span><span class="hljs-meta">@DefaultProperties(defaultFallback = <span class="hljs-meta-string">"globalFallbackMethod"</span>)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HystrixController</span> </span>&#123;    <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> Service service;    <span class="hljs-meta">@GetMapping(<span class="hljs-meta-string">"timeout/&#123;id&#125;"</span>)</span>    <span class="hljs-meta">@HystrixCommand</span>    <span class="hljs-keyword">public</span> String timeOut(<span class="hljs-meta">@PathVariable(<span class="hljs-meta-string">"id"</span>)</span> Integer id)&#123;        log.info(<span class="hljs-string">"我是超时的访问-------------id:&#123;&#125;"</span>,id);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.service.timeOut(id);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 全局fallback 方法</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> String globalFallbackMethod() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"你错了"</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记/微服务/3-0-0 断路器之Hystrix 简介</title>
    <link href="/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/3-0-0%20%E6%96%AD%E8%B7%AF%E5%99%A8%E4%B9%8BHystrix%20%E7%AE%80%E4%BB%8B/"/>
    <url>/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/3-0-0%20%E6%96%AD%E8%B7%AF%E5%99%A8%E4%B9%8BHystrix%20%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="分布式系统面临的问题"><a href="#分布式系统面临的问题" class="headerlink" title="分布式系统面临的问题"></a>分布式系统面临的问题</h3><p><strong style="color:red">复杂分布式体系结构中的应用程序有数十个依赖关系,每个依赖关系在某些时候将不可避免地失败。</strong></p><p><strong><strong style="color:green">服务雪崩</strong></strong></p><ul><li>多个微服务之间调用的时候,假设微服务A调用微服务B和微服务C,微服务B和微服务C又调用其它的微服务,这就是所谓的“<strong><strong style="color:red">扇出</strong></strong>” 。如果扇出的链路上某个微服务的调用响应时间过长或者不可用,对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃,所谓的” 雪崩效应”</li><li>对于高流量的应用来说，单一的后端依赖可能会导致所有服务器 上的所有资源都在几秒钟内饱和。比失败更糟糕的是,这些应用程序还可能导致服务之间的延迟增加，备份队列，线程和其他系统资源紧涨，导致整个系统发生更多的级联故障。这些都表示需要对故障和延迟进行隔离和管理，以便单个依赖关系的失败,不能取消整个应用程序或系统。所以,通常当你发现一个模块下的某个实例失败后,这时候这个模块依然还会接收流量,然后这个有问题的模块还调用了其他的模块,这样就会发生级联故障，或者叫雪崩。</li></ul><p><strong style="color:"></strong></p><h3 id="Hystrix简介"><a href="#Hystrix简介" class="headerlink" title="Hystrix简介"></a>Hystrix简介</h3><p>Hystrix是一个用于处理分布式系统的<strong style="color:red">延迟</strong>和<strong style="color:red">容错</strong>的开源库, 在分布式系统里,许多依赖不可避免的会调用失败，比如超时、异常等,<br>Hystrix能够保证在-个依赖出问题的情况下，<strong style="color:red">导致整体服务失败,避免级联故障,以提高分布式系统的弹性。</strong></p><p>“断路器”本身是一种开关装置， 当某个服务单元发生故障之后,通过断路器的故障监控(类似熔断保险丝)，<strong style="color:red">向调用方返回一个符合预期的、可处理的备选响应(FallBack) ，而不是长时间的等待或者抛出调用方无法处理的异常,</strong>这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延,乃至雪崩。</p><h3 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h3><p><strong>服务降级</strong></p><p>服务器忙，请稍后再试，不让客户端等待并立刻返回一个友好提示。<strong style="color:red">Fallback</strong></p><p>会触发的情况：</p><ul><li>​    程序运行异常</li><li>超时</li><li>服务熔断触发服务降级</li><li>线程池/信号量打满也会导致服务降级</li></ul><p><strong>服务熔断</strong></p><p>类似于生活中的保险丝，当到达最大服务访问后，直接拒绝访问，拉闸断电，然后调用<strong style="color:red">服务降级</strong>返回友好提示</p><p>服务降级 -&gt; 进而熔断-&gt; 恢复调用链路</p><p><strong>服务限流</strong></p><p>秒杀高并发等操作，严禁一窝蜂的进来拥挤，大家排队，一秒钟n个，有序进行</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记/微服务/2-1-1 OpenFegin 的使用</title>
    <link href="/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/2-1-1%20OpenFegin%20%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/2-1-1%20OpenFegin%20%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><strong>引入pom</strong></p><pre><code class="hljs java">&lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;        &lt;/dependency&gt;</code></pre><p><strong>配置application.yml</strong></p><pre><code class="hljs java"># 设置feign客户端超时时间（openFeign 默认支持ribbon）ribbon:#指建立连接所用的时间，适用网咯状况正常的情况下，两端所用的时间  ReadTimeout:  <span class="hljs-number">5000</span>#  指建立连接后从服务器读取到可用资源的时间 默认一秒    ConnectTimeout: <span class="hljs-number">5000</span></code></pre><p><strong>编写启动类</strong></p><pre><code class="hljs java"><span class="hljs-comment">// 使用Feign</span><span class="hljs-meta">@EnableFeignClients</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(Application<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre><p><strong>编写service层</strong></p><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-comment">//  feign接口 value= 指定服务 名称  </span><span class="hljs-meta">@FeignClient</span>(value = <span class="hljs-string">"xxx"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PaymentFeignService</span> </span>&#123;<span class="hljs-comment">// 向提供服务端 请求数据  请求服务类的数据</span>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"payment/get/&#123;id&#125;"</span>)    <span class="hljs-comment">//   feign的话@PathVariable("id") 中的必须指定value ，</span>    <span class="hljs-comment">//不然会报错： PathVariable annotation was empty on param 0.</span>     <span class="hljs-function">CommonResult&lt;XXX&gt; <span class="hljs-title">getPaymentById</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> Long id)</span>;&#125;</code></pre><p><strong>controller层直接调用service就行了</strong></p><pre><code class="hljs java"><span class="hljs-meta">@Slf</span>4j<span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">xxxControoler</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> Service service;<span class="hljs-comment">// 我们服务层请求的地址</span>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"consumer/payment/get/&#123;id&#125;"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult <span class="hljs-title">getPaymentById</span><span class="hljs-params">(@PathVariable Long  id)</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.service.getPaymentById(id);    &#125;&#125;</code></pre><h3 id="配置Feign日志"><a href="#配置Feign日志" class="headerlink" title="配置Feign日志"></a>配置Feign日志</h3><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> WeiMao</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-08-23 11:22</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FeignConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    Logger.<span class="hljs-function">Level <span class="hljs-title">feignLoggerLevel</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> Logger.Level.FULL;    &#125;&#125;</code></pre><p>*<em>日志级别 *</em></p><table><thead><tr><th>none</th><th>默认的，不开启任何日志</th></tr></thead><tbody><tr><td><strong>basic</strong></td><td>仅记录请求方法，URL,响应编码及执行时间</td></tr><tr><td><strong>HEADERS</strong></td><td>除 <strong>basic日志级别之外</strong>， 还有请求头，响应头的信息</td></tr><tr><td><strong>FULL</strong></td><td>除 <strong>HEADERS</strong> 还有请求和响应的正文及源数据</td></tr></tbody></table><p>配置application.yml</p><pre><code class="hljs java">logging:  level:#    feign 日志以什么级别监控那个接口    com.weimao.springcloud.service.xxxxxService: debug</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记/微服务/2-1-0   openFeign 简介</title>
    <link href="/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/2-1-0%20%20%20openFeign%20%E7%AE%80%E4%BB%8B/"/>
    <url>/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/2-1-0%20%20%20openFeign%20%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>​        Feign是一个 声明式WebService客户端。使用Feign能让编写Web Service客户端更加简单。</p><p>它的使用方法是定义一个服务接口然后在上面添加注解。Feign也支持可拔插式的编码器和解码器。Spring Cloud对Feign进行了封装，使其支持了Spring MVC标准注解和HttpMessageConverters。Feign可以 与Eureka和Ribbon组合使用以支持负载均衡</p><h3 id="能干什么"><a href="#能干什么" class="headerlink" title="能干什么"></a>能干什么</h3><p>Feign旨在使编写Java Http客户端变得更容易。<br>在使用Ribbon+ RestTemplate时,利用RestTemplate对http请求的封装处理，形成了-套模版化的调用方法。但是在实际开发中，于对服务依赖的调用可能不止一处,往往一个接口会被 多处调用，所以通常都会针对每个微服务自行封装一些客户端类来包装<br>这些依赖服务的调用。所以，Feign在此基础上做了进一步封装, 由他来帮助我们定义和实现依赖服务接口的定义。在Feign的实现 下<br>我们只需创建一个接口并使用注解的方式来配置它(以前是Dao接口上面标注Mapper注解现在是-个微服务接口.上面标注一个<br>Feign注解即可)，即可完成对服务提供方的接口绑定,简化了使用Spring cloud Ribbon时,自动封装服务调用客户端的开发量。</p><h3 id="Feign-集成了Ribbon"><a href="#Feign-集成了Ribbon" class="headerlink" title="Feign 集成了Ribbon"></a>Feign 集成了Ribbon</h3><p>利用Ribbon维护了xxx的服务列表信息，并且通过轮询实现了客户端的负载均衡。而与Ribbon不同的是，通过feign只需要定 义服务绑定接口且以声明式的方法，优雅而简单的实现了服务调用</p><h3 id="Feign-跟openFeign-区别"><a href="#Feign-跟openFeign-区别" class="headerlink" title="Feign 跟openFeign 区别"></a>Feign 跟openFeign 区别</h3><table><thead><tr><th>Feign</th><th>OpenFeign</th></tr></thead><tbody><tr><td>Feign是Spring Cloud组件中的一个轻量RESTful的HTTP服务客户端</td><td></td></tr><tr><td>Feign内置了Ribbgn,用来做客户端负载均衡，去调用服务注册中心的</td><td></td></tr><tr><td>服务。Feign的使用方式是:使用Feign的注解定义接口，调用这个接口</td><td></td></tr><tr><td>就可以调用服务注册中心的服务</td><td>OpenFeign是Spring Cloud在Feign的基础上支持了SpringMVC的注解，如@RequesMapping等等。OpenFeign的@FeignClient可以解析SpringMVC的@RequestMapping注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务。</td></tr><tr><td><dependency></td><td></td></tr><tr><td><groupId>org. springframework . cloud&lt;/ groupId&gt;</td><td></td></tr><tr><td><artifactId>spring-cloud-starter-feign</artifactId></td><td></td></tr><tr><td></dependency></td><td><dependency><br/><groupId>org. springframework. cloud&lt;/ groupId&gt;<br/><artifactId>spring-cloud-starter-openfeign&lt;/ artifactId&gt;<br/></dependency></td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记/微服务/2-0-3 自己写一个 本地负载均衡 器</title>
    <link href="/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/2-0-3%20%E8%87%AA%E5%B7%B1%E5%86%99%E4%B8%80%E4%B8%AA%20%E6%9C%AC%E5%9C%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%20%E5%99%A8/"/>
    <url>/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/2-0-3%20%E8%87%AA%E5%B7%B1%E5%86%99%E4%B8%80%E4%B8%AA%20%E6%9C%AC%E5%9C%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%20%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="第一步定义一个接口"><a href="#第一步定义一个接口" class="headerlink" title="第一步定义一个接口"></a>第一步定义一个接口</h3><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.springcloud.lb;<span class="hljs-keyword">import</span> org.springframework.cloud.client.ServiceInstance;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> WeiMao</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-08-19 21:41</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">LoadBalancer</span> </span>&#123;    <span class="hljs-function">ServiceInstance <span class="hljs-title">instances</span><span class="hljs-params">(List&lt;ServiceInstance&gt; serviceInstances)</span></span>;&#125;</code></pre><h3 id="第二步实现它"><a href="#第二步实现它" class="headerlink" title="第二步实现它"></a>第二步实现它</h3><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-meta">@Slf</span>4j<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyLoadBalancer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">LoadBalancer</span> </span>&#123;<span class="hljs-comment">//   线程安全，保证不会并发线程同时访问的情况 给一个初始值为0</span>    AtomicInteger atomicInteger =<span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);   <span class="hljs-comment">/**</span><span class="hljs-comment">     * 第几次访问</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndInstance</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">int</span> current;        <span class="hljs-keyword">int</span> next;        <span class="hljs-keyword">do</span>&#123;            <span class="hljs-comment">//  获取当前值</span>            current=<span class="hljs-keyword">this</span>.atomicInteger.get();            current=next = current &gt;= Integer.MAX_VALUE ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span> + current;            <span class="hljs-comment">// cas 比较并替换  第一个参数预期值，第二个更新值 </span>            <span class="hljs-comment">// 如果预期值等于当前值，则更新值：atomicInteger.get()=next;返回true</span>            <span class="hljs-comment">// 反之 则什么都不做</span>        &#125;<span class="hljs-keyword">while</span>(!<span class="hljs-keyword">this</span>.atomicInteger.compareAndSet(current, next));        log.info(<span class="hljs-string">"第---&#123;&#125;---访问次"</span>, next);        <span class="hljs-keyword">return</span> next;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 返回当前服务</span><span class="hljs-comment">     * serviceInstances  当前节点上的所有服务</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ServiceInstance <span class="hljs-title">instances</span><span class="hljs-params">(List&lt;ServiceInstance&gt; serviceInstances)</span> </span>&#123;        <span class="hljs-keyword">int</span> index = <span class="hljs-keyword">this</span>.getAndInstance() % serviceInstances.size();        <span class="hljs-keyword">return</span> serviceInstances.get(index);    &#125;&#125;</code></pre><h3 id="第三步测试"><a href="#第三步测试" class="headerlink" title="第三步测试"></a>第三步测试</h3><p><strong>前提先搭建服务集群 方便测试  （我这里用的eureka不一定要用eureka 其他的也可以）</strong></p><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@Slf</span>4j<span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"test"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderController</span> </span>&#123;        <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;        <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> DiscoveryClient discoveryClient;                <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/lb"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testLoadBalancer</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//  获取指定服务所有实例</span>        List&lt;ServiceInstance&gt; instances = <span class="hljs-keyword">this</span>.discoveryClient.getInstances(<span class="hljs-string">"CLOUD-PAYMENT-SERVICE"</span>);        <span class="hljs-keyword">if</span> (instances.isEmpty()) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        ServiceInstance instances1 = <span class="hljs-keyword">this</span>.loadBalancer.instances(instances);<span class="hljs-comment">// 访问我们要访问的地址并返回</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.restTemplate.getForObject(instances1.getUri()+<span class="hljs-string">"payment/lb"</span>, String<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    &#125;    &#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记/微服务/2-0-2 Ribbon 负载均衡 自定义机制规则</title>
    <link href="/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/2-0-2%20Ribbon%20%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9C%BA%E5%88%B6%E8%A7%84%E5%88%99/"/>
    <url>/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/2-0-2%20Ribbon%20%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9C%BA%E5%88%B6%E8%A7%84%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h3 id="自定义配置规则-默认轮询"><a href="#自定义配置规则-默认轮询" class="headerlink" title="自定义配置规则 默认轮询"></a>自定义配置规则 默认轮询</h3><p>官文档明确给出了警告: ;<br>这个自定义配置类不能放在@ComponentScan所扫描的当前包下以及子包下，<br>否则我们自定义的这个配置类就会被所有的Ribbon客户端所共享,达不到特殊化定制的目的了。</p><h3 id="首先要先建配置包-层级必须在Springboot-启动类之上："><a href="#首先要先建配置包-层级必须在Springboot-启动类之上：" class="headerlink" title="首先要先建配置包 层级必须在Springboot 启动类之上："></a>首先要先建配置包 层级必须在Springboot 启动类之上：</h3><p>如</p><pre><code class="hljs css"><span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.xxx</span><span class="hljs-selector-class">.springcloud</span><span class="hljs-selector-class">.Application</span><span class="hljs-selector-class">.java</span>  启动类目录<span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.xxx</span><span class="hljs-selector-class">.myRule</span><span class="hljs-selector-class">.xxxConfig</span><span class="hljs-selector-class">.java</span>  配置类目录</code></pre><h2 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h2><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySelfRuleConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> IRule <span class="hljs-title">myRule</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//  配置随机规则替换轮询</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RandomRule();    &#125;&#125;</code></pre><h3 id="启动类上加上注解"><a href="#启动类上加上注解" class="headerlink" title="启动类上加上注解"></a>启动类上加上注解</h3><pre><code class="hljs java"><span class="hljs-meta">@EnableEurekaClient</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-comment">// name 需要访问的微服务名称， configuration 配置规则类</span><span class="hljs-meta">@RibbonClient</span>(name = <span class="hljs-string">"CLOUD-PAYMENT-SERVICE"</span>,configuration = MySelfRuleConfig<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">OrderMain80</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(OrderMain80<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre><h3 id="负载均衡的算法"><a href="#负载均衡的算法" class="headerlink" title="负载均衡的算法"></a>负载均衡的算法</h3><p>​    <strong>rest 接口第几次请求数 %  服务集群总数量=实际条用服务器下标</strong></p><p><strong>每次服务重启后rest接口记数从1开始</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记/微服务/2-0-1 Ribbon 负载均衡的机制 </title>
    <link href="/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/2-0-1%20Ribbon%20%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E6%9C%BA%E5%88%B6%20/"/>
    <url>/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/2-0-1%20Ribbon%20%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E6%9C%BA%E5%88%B6%20/</url>
    
    <content type="html"><![CDATA[<h4 id="Ribbon-的核心组件IRule"><a href="#Ribbon-的核心组件IRule" class="headerlink" title="Ribbon 的核心组件IRule"></a>Ribbon 的核心组件IRule</h4><p><strong>机制规则：</strong></p><ul><li><p>com.netflix.loadbalancer.RoundRobinRule ：轮询</p></li><li><p>com.netflix.loadbalancer.RandomRule  ： 随机</p></li><li><p>com.neflix.loadbalancer.RetryRule ： 对RoundRobinRule的扩展，响应速度越快的实例选择权重越大，越容易被选择</p></li><li><p>WeightedResponse TimeRule ： 对RoundRobinRule的扩展，响应速度越快的实例选择权重越大，越容易被选择</p></li><li><p>BestAvailableRule： 会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务</p></li><li><p>AvailabilityFilteringRule ： 先过滤掉故障实例，再选择并发较小的实例</p></li><li><p>ZoneAvoidanceRule ： 默认规则，复合判断server所在区 域的性能和server的可用性选择服务器</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记/微服务/2-0-0 Ribbon负载均衡服务调用</title>
    <link href="/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/2-0-0%20Ribbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/"/>
    <url>/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/2-0-0%20Ribbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>是基于Netflix ribbon实现的一套 <strong>客户端 负载均衡的工具</strong></p><p>主要功能是   <strong>提供客户端的软件负载均衡算法和服务调用</strong></p><p>Ribbon客户端组件 提供-系列<br>完善的配置项如连接超时，重试等。简单的说，就是在配置文件中列出Load Balancer (简称LB)后面所有的机器，Ribbon会自动的帮<br>助你基于某种规则(如简单轮询，随机连接等)去连接这些机器。我们很容易使用Ribbon实现自定义的负载均衡算法。</p><h3 id="LB负载均衡-Load-Balance-是什么"><a href="#LB负载均衡-Load-Balance-是什么" class="headerlink" title="LB负载均衡(Load Balance)是什么"></a>LB负载均衡(Load Balance)是什么</h3><p>简单的说就是将用户的请求平摊的分配到多个服务上,从而达到系统的HA (高可用)。<br>常见的负载均衡有软件Nginx, LVS,硬件F5等。</p><h3 id="Ribbon本地负载均衡客户端VS-Nginx服务端负载均衡区别"><a href="#Ribbon本地负载均衡客户端VS-Nginx服务端负载均衡区别" class="headerlink" title="Ribbon本地负载均衡客户端VS Nginx服务端负载均衡区别"></a>Ribbon本地负载均衡客户端VS Nginx服务端负载均衡区别</h3><p>Nginx是服务器负载均衡，客户端所有请求都会交给nginx,然后由nginx实现转发请求。即负载均衡是由服务端实现的。<br>Ribbon本地负载均衡，在调用微服务接口时候，会在注册中心上获取注册信息服务列表之后缓存到JVM本地，从而在本地实现RPC远程服务调用技术。</p><h3 id="集中式LB"><a href="#集中式LB" class="headerlink" title="集中式LB"></a>集中式LB</h3><p>即在服务的消费方和提供方之 间使用独立的B设施(可以是硬件,如F5,也可以是软件, 如nginx),由该设施负责把访问请求通过某种策略转发至服务的提供方; .</p><h3 id="进程内LB"><a href="#进程内LB" class="headerlink" title="进程内LB"></a>进程内LB</h3><p>将L B逻辑集成到消费方,消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器。Ribbon就属于进程内LB,它只是一个类库, 集成于消费方进程,消费方通过它来获取到服务提供方的地址。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Ribbon就是一个软负载均衡的客户端组件，他可以和其他请求的客户端接口使用，和Eureka结合只是其中的一个实例。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记/微服务/1-2-1 注册中心之 consul 搭建</title>
    <link href="/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/1-2-1%20%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E4%B9%8B%20consul%20%E6%90%AD%E5%BB%BA/"/>
    <url>/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/1-2-1%20%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E4%B9%8B%20consul%20%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h3 id="基于springcloud搭建"><a href="#基于springcloud搭建" class="headerlink" title="基于springcloud搭建"></a>基于springcloud搭建</h3><p><strong>pom配置</strong></p><pre><code class="hljs java">&lt;!-- https:<span class="hljs-comment">//mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-consul-discovery --&gt;</span>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p><strong>application,yml</strong></p><pre><code class="hljs java">server:  port: <span class="hljs-number">80</span>spring:  application:    name: consul-consumer-order  cloud:    consul:      host: localhost # consul 安装地址      port: 8500  # consul web 访问端口 配置成功的服务 在这里显示         discovery:        service-name: $&#123;spring.application.name&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记/微服务/1-2-0 注册中心之consul 简介</title>
    <link href="/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/1-2-0%20%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E4%B9%8Bconsul%20%E7%AE%80%E4%BB%8B/"/>
    <url>/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/1-2-0%20%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E4%B9%8Bconsul%20%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="是什么："><a href="#是什么：" class="headerlink" title="是什么："></a>是什么：</h3><p>是一套开源的分布式服务发现和配置管理系统，由HashiCorp 公司用Go语言开发。</p><p>提供了微服务系统中服务治理。配置中心。控制总线等功能。这些功能每一个可以根据需要单独使用网咯，</p><p><strong>总之Consul提供了一种完整的服务网咯解决方案</strong></p><p>优点：</p><ul><li>基于raft协议，简洁</li><li>支持健康检查，同时支持HTTP和DNS协议</li><li>跨平台</li></ul><h3 id="能干嘛"><a href="#能干嘛" class="headerlink" title="能干嘛"></a>能干嘛</h3><ul><li>服务发现 –提供HTTP和DNS两种发现方式</li><li>健康监测 —-支持多种协议，HTTP,TCP,Docker,shell 脚本定制化</li><li>键值对储存</li><li>多数据中心</li><li>可视化Web界面</li></ul><p>去官网下载有<a href="https://www.consul.io/downloads" target="_blank" rel="noopener"><strong>Linux、Windows、Mac版</strong></a>  </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记/微服务/1-1-0 注册中心之 zookeeper 介绍</title>
    <link href="/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/1-1-0%20%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E4%B9%8B%20zookeeper%20%E4%BB%8B%E7%BB%8D/"/>
    <url>/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/1-1-0%20%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E4%B9%8B%20zookeeper%20%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记/微服务/1-0-3  三个注册中心的异同点 eureka，zookeeper，consul </title>
    <link href="/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/1-0-3%20%20%E4%B8%89%E4%B8%AA%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E7%9A%84%E5%BC%82%E5%90%8C%E7%82%B9%20eureka%EF%BC%8Czookeeper%EF%BC%8Cconsul%20/"/>
    <url>/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/1-0-3%20%20%E4%B8%89%E4%B8%AA%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E7%9A%84%E5%BC%82%E5%90%8C%E7%82%B9%20eureka%EF%BC%8Czookeeper%EF%BC%8Cconsul%20/</url>
    
    <content type="html"><![CDATA[<table><thead><tr><th>组件名</th><th>语言</th><th>CAP</th><th>服务健康监测</th><th>对外暴露接口</th><th>springcloud集成</th></tr></thead><tbody><tr><td>eureka</td><td>java</td><td>ap</td><td>可配支持</td><td>HTTP</td><td>集成</td></tr><tr><td>zookeeper</td><td>java</td><td>cp</td><td>支持</td><td>客户端</td><td>集成</td></tr><tr><td>consul</td><td>go</td><td>cp</td><td>支持</td><td>HTTP/DNS</td><td>集成</td></tr></tbody></table><p>CAP:  Availability(可用性)  Consistency (强一致性 )  Partition tolerance(分区容错性)</p><p>CAP理论关注粒度是数据，而不是整体系统设计的策略</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记/微服务/1-0-2 注册中心之eureka集群原理</title>
    <link href="/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/1-0-2%20%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E4%B9%8Beureka%E9%9B%86%E7%BE%A4%E5%8E%9F%E7%90%86/"/>
    <url>/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/1-0-2%20%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E4%B9%8Beureka%E9%9B%86%E7%BE%A4%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记/微服务/1-0-1 注册中心之eureka 集群搭建</title>
    <link href="/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/1-0-1%20%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E4%B9%8Beureka%20%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
    <url>/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/1-0-1%20%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E4%B9%8Beureka%20%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h3 id="eureka集群搭建"><a href="#eureka集群搭建" class="headerlink" title="eureka集群搭建"></a>eureka集群搭建</h3><p><strong>搭建这个很简单:smile_cat:</strong></p><p>就是两个<strong>服务互相注册，互相守望</strong></p><p>话不多说上代码：</p><pre><code class="hljs java">## 两个都是server 端 pox 都是这个        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;        &lt;/dependency&gt;</code></pre><p><strong>Yml配置</strong></p><pre><code class="hljs java">##  两个配置 其实都差不多 互相监听## server 配置##  7001配置eureka:  instance:    hostname: eureka7001.com  # eureka服务端实例名称  client:    register-with-eureka: false # false  表示不向注册中心注册自己    fetch-registry: false # false 表示自己就是注册中心，我的职责就是维护实例，并不需要检索服务    service-url:      ##  设置与eureka server交互的地址查询和注册服务都需要依赖这个地址      defaultZone: http:<span class="hljs-comment">//eureka7002.com:7002/eureka</span>##  7002配置eureka:  instance:    hostname: eureka7002.com  client:    register-with-eureka: false # false  表示不向注册中心注册自己    fetch-registry: false # false 表示自己就是注册中心，我的职责就是维护实例，并不需要检索服务    service-url:      ##  设置与eureka server交互的地址查询和注册服务都需要依赖这个地址      defaultZone: http:<span class="hljs-comment">//eureka7001.com:7001/eureka</span>###  客户端配置eureka:  client:    #  表示是否将自己注册进EurekaServer  默认为true    register-with-eureka: <span class="hljs-keyword">true</span>    ## 是否从EurekaServer 抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡    fetchRegistry: <span class="hljs-keyword">true</span>    service-url:#     defaultZone: http://localhost:7001/eureka  # 单机版      defaultZone: http:<span class="hljs-comment">//eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka </span>instance-id: payment8001 #  实例名称（微服名称）    prefer-ip-address: true  # 微服务显示的是IP地址而不是 如：localhost  地址    # eureka服务端在收到最后一次心跳后等待时间上线，单位微秒（默认 90秒），超时将剔除服务    lease-expiration-duration-in-seconds: <span class="hljs-number">2</span>#   eureka 客户端向客户端向服务端发送心跳的时间间隔，单位为秒（默认30秒）    lease-renewal-interval-in-seconds:  <span class="hljs-number">1</span>eureka:  client:    #  表示是否将自己注册进EurekaServer  默认为true    register-with-eureka: <span class="hljs-keyword">true</span>    ## 是否从EurekaServer 抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡    fetchRegistry: <span class="hljs-keyword">true</span>    service-url:#     defaultZone: http://localhost:7001/eureka  # 单机版      defaultZone: http:<span class="hljs-comment">//eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka </span>instance-id: payment8002 #  实例名称    prefer-ip-address: true  # 微服务访问路劲显示的是IP地址而不是 如：localhost  地址</code></pre><p>//  只测试一个客户端  //  另外代码一样</p><h3 id="测试获取eureka信息-slightly-smiling-face"><a href="#测试获取eureka信息-slightly-smiling-face" class="headerlink" title="测试获取eureka信息 :slightly_smiling_face:"></a>测试获取eureka信息 :slightly_smiling_face:</h3><pre><code class="hljs java"><span class="hljs-comment">//  去启动类中加入 @EnableDiscoveryClient   我这边不加也没事</span><span class="hljs-comment">//  去controller 层 </span><span class="hljs-meta">@RestController</span><span class="hljs-meta">@Slf</span>4j<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestController</span> </span>&#123;        <span class="hljs-meta">@autowired</span>     <span class="hljs-keyword">private</span> DiscoveryClient discoveryClient;             <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"discovery"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">discovery</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//        获取服务列表对应 注册中心上有几个微服务</span>        List&lt;String&gt; services = <span class="hljs-keyword">this</span>.discoveryClient.getServices();        <span class="hljs-keyword">for</span> (String service : services) &#123;            log.info(<span class="hljs-string">"*********server:&#123;&#125;"</span>, service);        &#125;<span class="hljs-comment">//        获取该微服务下的全部实例</span>        List&lt;ServiceInstance&gt; instances = <span class="hljs-keyword">this</span>.discoveryClient.getInstances(<span class="hljs-string">"CLOUD-PAYMENT-SERVICE"</span>);        <span class="hljs-keyword">for</span> (ServiceInstance instance : instances) &#123;            log.info(<span class="hljs-string">"服务id:&#123;&#125;-主机名称:&#123;&#125;-主机端口号&#123;&#125;-URI地址&#123;&#125;"</span>                ,instance.getServiceId(),instance.getHost(),instance.getPort(),instance.getUri());        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.discoveryClient;    &#125;        &#125;</code></pre><h3 id="Eureka-自我保护-机制（属于Cap中的ap）-默认开启"><a href="#Eureka-自我保护-机制（属于Cap中的ap）-默认开启" class="headerlink" title="Eureka  自我保护 机制（属于Cap中的ap） 默认开启"></a>Eureka  自我保护 机制（属于Cap中的ap） 默认开启</h3><p>某时某刻一个微服务 不可用了（如：网咯延迟） ，eureka不会立即清理，依旧会对该服务的信息进行保存</p><pre><code class="hljs java"><span class="hljs-comment">// 服务端</span>eureka:server:enable-self-preservation: <span class="hljs-keyword">false</span>  <span class="hljs-comment">//  关闭自我保护，保证服务不可用就立即剔除</span></code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记/微服务/1-0-0 注册中心之eureka</title>
    <link href="/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/1-0-0%20%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E4%B9%8Beureka/"/>
    <url>/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/1-0-0%20%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E4%B9%8Beureka/</url>
    
    <content type="html"><![CDATA[<h2 id="springboot（Cloud）配置eureka"><a href="#springboot（Cloud）配置eureka" class="headerlink" title="springboot（Cloud）配置eureka"></a>springboot（Cloud）配置eureka</h2><p>​        springCloud  H版之后</p><p>使用最新的的版本（因为容易分清 不容易混淆）</p><h3 id="版本对比"><a href="#版本对比" class="headerlink" title="版本对比"></a>版本对比</h3><p><strong>旧版</strong></p><pre><code class="hljs java">&lt;dependency&gt;     &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;     &lt;artifactId&gt;spring-cloud-starter-eurekar&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p><strong>新版</strong></p><pre><code class="hljs java"> ## 服务端(管理)   eureka 服务端使用 &lt;dependency&gt;      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;      &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;  &lt;/dependency&gt;##  客户端  想把服务自己的服务注册到eureka服务使用这个&lt;dependency&gt;     &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;     &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt;</code></pre><h3 id="YMl-配置"><a href="#YMl-配置" class="headerlink" title="YMl 配置"></a>YMl 配置</h3><p><strong>server端</strong></p><pre><code class="hljs java">eureka:  instance:    hostname: localhost  # eureka服务端实例名称  client:    register-with-eureka: false # false  表示不向注册中心注册自己    fetch-registry: false # false 表示自己就是注册中心，我的职责就是维护实例，并不需要检索服务    service-url:      ##  设置与eureka server交互的地址查询和注册服务都需要依赖这个地址      defaultZone: http:<span class="hljs-comment">//$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka</span></code></pre><p><strong>client</strong> 端</p><pre><code class="hljs java">  ##  eureka  客户端配置eureka:  client:    #  表示是否将自己注册进EurekaServer  默认为true    register-with-eureka: <span class="hljs-keyword">true</span>    ## 是否从EurekaServer 抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡    fetchRegistry: <span class="hljs-keyword">true</span>    service-url:      defaultZone: http:<span class="hljs-comment">//localhost:服务端地址/eureka</span></code></pre><h3 id="启动类配置"><a href="#启动类配置" class="headerlink" title="启动类配置"></a>启动类配置</h3><p><strong>server端</strong>  </p><pre><code class="hljs java"><span class="hljs-comment">//  启动类加上 @EnableEurekaServer</span><span class="hljs-meta">@EnableEurekaServer</span>   <span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(Application<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre><hr><p><strong>client端</strong></p><pre><code class="hljs java"><span class="hljs-comment">//  启动类加上 @EnableEurekaClient</span><span class="hljs-meta">@EnableEurekaClient</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(Application<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre><p>// 注意 启动时候优先启动 server端  因为  服务端不启动  客户端 注册不进去 </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记/微服务/0-0-1 springCloud</title>
    <link href="/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/0-0-1%20springCloud/"/>
    <url>/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/0-0-1%20springCloud/</url>
    
    <content type="html"><![CDATA[<h3 id="springcloud"><a href="#springcloud" class="headerlink" title="springcloud"></a>springcloud</h3><p>：springcloud是基于springBoot提供一套微服务解决方案，包括服务注册与发现，配置中心，全链路监控，服务网关，负载均衡，熔断器等组件。除了 基于NetFlix的开源组件做高度抽象封装外，还有一些选型中立的开源组件。</p><p>利用springBoot的开发便利简化了分布式系统的基础设施的开发，springCloud为开发人员提供了快速构建分布式系统的一些工具：</p><ul><li>配置管理</li><li>服务发现</li><li>断路器</li><li>路由</li><li>微代理</li><li>事件总线</li><li>全局锁</li><li>决策竞选</li><li>分布式会话等</li></ul><p>利用springBoot开发风格做到一键启动和部署 </p><p>将目前各家公司开发比较成熟的，经的考验的服务框架组合起来，通过springBoot风格进行封装，屏蔽了复杂的配置和实现原理，最终给开发者的流出一套简单易懂，易部署和易维护的分布式系统开发工具包。</p><p><strong>springCLoud 是微服务一站式解决方案</strong></p><h3 id="springCloud-对比-Dubbo"><a href="#springCloud-对比-Dubbo" class="headerlink" title="springCloud 对比 Dubbo"></a>springCloud 对比 Dubbo</h3><p><strong>Dubbo</strong> 是一款RPC 框架</p><p><strong>springcloud</strong> 目标是一站式解决方案</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记/微服务/0-0-0 什么是微服务，优缺点</title>
    <link href="/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/0-0-0%20%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1%EF%BC%8C%E4%BC%98%E7%BC%BA%E7%82%B9/"/>
    <url>/2020/11/25/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/0-0-0%20%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1%EF%BC%8C%E4%BC%98%E7%BC%BA%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务"></a>什么是微服务</h3><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点</strong></p><ul><li>每个服务足够内聚，足够小，代码容易理解 专注于一个业务</li><li>开发简单，效率高 ，一个服务只干一件事</li><li>能够被小团队（2-5人）单独开发</li><li>是松耦合的，有功能意义的服务，无论是开发还是部署阶段都是独立的</li><li>多语言开发</li><li>易于第三方集成</li><li>便于修改和维护</li><li>每个微服都有自己的存储能力，都可以有自己的数据库，也可以统一数据库，灵活搭配</li></ul><p><strong>缺点</strong></p><ul><li>开发人员要处理分布式系统的复杂性</li><li>多服务运维成本，随着服务的增加，运维压力大</li><li>服务之间的通信成本</li><li>数据的一致性</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2020/02/10/%E7%AC%94%E8%AE%B0/Git/git%E5%91%BD%E4%BB%A4%E5%92%8CIDEA%E7%9A%84git/"/>
    <url>/2020/02/10/%E7%AC%94%E8%AE%B0/Git/git%E5%91%BD%E4%BB%A4%E5%92%8CIDEA%E7%9A%84git/</url>
    
    <content type="html"><![CDATA[<h2 id="idea"><a href="#idea" class="headerlink" title="idea"></a>idea</h2><p>检出分支：     右下角<strong>checkout</strong> 你要检出的分支    切换分支一样</p><p>合并分支：    如我在dev 分支 写的代码想合并到master分支； 我先在dev 分支先提交 push 在切换到master分支</p><p>然后 去右下角 点击 dev 会看到merge into  curent 这样会把  dev提交的代码合并到master分支，在（master）push</p><p>Git：命令</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#  查看本地分支</span></span>git branch -a(所有分支，远程/本地  不加 显示本地分支)<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 切换分支</span></span>git checkout  -b  分支名<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 合并分支</span></span>git merge  dev  ##  把dev 分支合并到当前分支  提前是dev分支有提交代码   <span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 这样当前分支就有 dev分支的代码 当前分支在push  提交下几可以</span></span></code></pre><h5 id="git-更换提交地址"><a href="#git-更换提交地址" class="headerlink" title="git 更换提交地址"></a>git 更换提交地址</h5><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#  先删除原来的地址</span></span>git remote rm origin<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#  更换你要提交的地址</span></span>git remote add origin XXXX地址</code></pre><h4 id="如果账号密码有改动"><a href="#如果账号密码有改动" class="headerlink" title="如果账号密码有改动"></a>如果账号密码有改动</h4><pre><code class="hljs shell">git config --system  --unset credential.helper<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#  如果用了第一个命令 还不能解决问题那么 用这个命令：</span></span>git config –global http.emptyAuth true</code></pre>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>Idea</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建Hexo个人博客</title>
    <link href="/2020/02/10/%E7%AC%94%E8%AE%B0/%E5%8D%9A%E5%AE%A2/%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2/"/>
    <url>/2020/02/10/%E7%AC%94%E8%AE%B0/%E5%8D%9A%E5%AE%A2/%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>​    使用hexo搭建个人博客是一个朋友推荐的；因为可以说是完全<strong>免费</strong>，虽然我自己也有服务器，但是还是使用了这个，要问我为什么，就是搭建简单。<strong>ps : 程序员最缺的就是时间不是么</strong>  :smiley:</p><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><ul><li>​    下载 <a href="http://nodejs.org/" target="_blank" rel="noopener">node js</a>  </li><li>​    下载 <a href="http://git-scm.com/" target="_blank" rel="noopener">git</a>    Windows系统的 可以下载<a href="https://npm.taobao.org/mirrors/git-for-windows/" target="_blank" rel="noopener">淘宝镜像</a>比较快</li></ul><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><pre><code class="hljs javascript">npm install -g hexo-cli</code></pre><pre><code class="hljs javascript">hexo -v  <span class="hljs-comment">//  检验是否安装成功</span></code></pre><h3 id="配置博客"><a href="#配置博客" class="headerlink" title="配置博客"></a>配置博客</h3><pre><code class="hljs kotlin"><span class="hljs-comment">//  创建myblog</span>mkdir myblog<span class="hljs-comment">//  进入 博客目录</span>cd myblog <span class="hljs-comment">// 初始化</span>hexo <span class="hljs-keyword">init</span></code></pre><p><img src="D:%5C%E7%AC%94%E8%AE%B0%5C%E5%8D%9A%E5%AE%A2%5C%E7%9B%AE%E5%BD%95.png" srcset="/img/loading.gif" alt=""></p><ul><li>node_modules: 依赖包</li><li>scaffolds：生成文章的一些模板</li><li>source：用来存放你的文章  一般自己写的笔记 丢到   <strong>source/_posts/</strong>  下就好了</li><li>themes：主题      ##  这个自己找（看看自己对页面功能的需求），用的最多的是  <a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">next</a>    我用的是 <a href="https://hexo.fluid-dev.com/" target="_blank" rel="noopener">fluid</a></li><li>** _config.yml: 博客的配置文件**</li></ul><pre><code class="hljs undefined">hexo g  &#x2F;&#x2F;  编译hexo s  &#x2F;&#x2F;  本地启动 默认4000 端口</code></pre><h3 id="把博客配置到GitHub-，这样所有人都能访问的到"><a href="#把博客配置到GitHub-，这样所有人都能访问的到" class="headerlink" title="把博客配置到GitHub ，这样所有人都能访问的到"></a>把博客配置到GitHub ，这样所有人都能访问的到</h3><p> <strong>前提：个人必须要有一个GitHub的账号</strong></p><ol><li><p>去 <a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>  新建一个工程 （要求： 格式必须是 用户名.github.io     比如 name.github.io）</p><p> <img src="D:%5C%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE%5C%E5%8D%9A%E5%AE%A2%5Cimage-20200726154043427.png" srcset="/img/loading.gif" alt=""></p></li></ol><pre><code>工程名必须 跟自己名称一致 加上 .Github.io  **我这里报错 的是因为之前创建了**![image-20200726154608047](D:\笔记截图\博客\image-20200726154608047.png)</code></pre><ol start="2"><li><p>然后去我们创建的博客根目录下  修改 <strong>_config.yml问价</strong>    找到 <code>deploy</code> 这个部分, 修改成</p> <pre><code class="hljs yml"><span class="hljs-attr">deploy:</span>    <span class="hljs-attr">type:</span> <span class="hljs-string">git</span>    <span class="hljs-attr">repo:</span> <span class="hljs-string">git@github.com:xxx/xxx.github.io.git</span>  <span class="hljs-comment">###  你在GitHub创建完工程 生成的地址</span>    <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span></code></pre></li><li><p>部署</p> <pre><code class="hljs javascript">hexo  cl  ##清理hexo  g  ## 编译   ##  每次操作完最好 执行一次，不然会发现你本地运行好好的，远程的内容跟你本地不一致npm install hexo-deployer-git --save   ## 安装git环境  hexo d  ##部署到GitHub   ##  他会让你输入GitHub的账号密码 输入一下就好了</code></pre></li></ol><p>这一步就完成了 然后试试访问一下部署的地址就好了  如：xxx.github.io  我的就是：weimao520.github.io   如果有点闲钱的话 最好自己买一个域名 配置下:smiley:</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>搭建hexo博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Other</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
