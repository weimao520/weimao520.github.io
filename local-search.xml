<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>笔记/微服务/1-0-2 注册中心之 zookeeper 介绍</title>
    <link href="/2020/08/06/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/1-0-2%20%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E4%B9%8B%20zookeeper%20%E4%BB%8B%E7%BB%8D/"/>
    <url>/2020/08/06/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/1-0-2%20%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E4%B9%8B%20zookeeper%20%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记/微服务/0-0-0 什么是微服务，优缺点</title>
    <link href="/2020/08/06/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/0-0-0%20%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1%EF%BC%8C%E4%BC%98%E7%BC%BA%E7%82%B9/"/>
    <url>/2020/08/06/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/0-0-0%20%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1%EF%BC%8C%E4%BC%98%E7%BC%BA%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务"></a>什么是微服务</h3><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点</strong></p><ul><li>每个服务足够内聚，足够小，代码容易理解 专注于一个业务</li><li>开发简单，效率高 ，一个服务只干一件事</li><li>能够被小团队（2-5人）单独开发</li><li>是松耦合的，有功能意义的服务，无论是开发还是部署阶段都是独立的</li><li>多语言开发</li><li>易于第三方集成</li><li>便于修改和维护</li><li>每个微服都有自己的存储能力，都可以有自己的数据库，也可以统一数据库，灵活搭配</li></ul><p><strong>缺点</strong></p><ul><li>开发人员要处理分布式系统的复杂性</li><li>多服务运维成本，随着服务的增加，运维压力大</li><li>服务之间的通信成本</li><li>数据的一致性</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2020/02/10/%E7%AC%94%E8%AE%B0/Git/git%E5%91%BD%E4%BB%A4%E5%92%8CIDEA%E7%9A%84git/"/>
    <url>/2020/02/10/%E7%AC%94%E8%AE%B0/Git/git%E5%91%BD%E4%BB%A4%E5%92%8CIDEA%E7%9A%84git/</url>
    
    <content type="html"><![CDATA[<h2 id="idea"><a href="#idea" class="headerlink" title="idea"></a>idea</h2><p>检出分支：     右下角<strong>checkout</strong> 你要检出的分支    切换分支一样</p><p>合并分支：    如我在dev 分支 写的代码想合并到master分支； 我先在dev 分支先提交 push 在切换到master分支</p><p>然后 去右下角 点击 dev 会看到merge into  curent 这样会把  dev提交的代码合并到master分支，在（master）push</p><p>Git：命令</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#  查看本地分支</span></span>git branch -a(所有分支，远程/本地  不加 显示本地分支)<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 切换分支</span></span>git checkout  -b  分支名<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 合并分支</span></span>git merge  dev  ##  把dev 分支合并到当前分支  提前是dev分支有提交代码   <span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 这样当前分支就有 dev分支的代码 当前分支在push  提交下几可以</span></span></code></pre><h5 id="git-更换提交地址"><a href="#git-更换提交地址" class="headerlink" title="git 更换提交地址"></a>git 更换提交地址</h5><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#  先删除原来的地址</span></span>git remote rm origin<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#  更换你要提交的地址</span></span>git remote add origin XXXX地址</code></pre><h4 id="如果账号密码有改动"><a href="#如果账号密码有改动" class="headerlink" title="如果账号密码有改动"></a>如果账号密码有改动</h4><pre><code class="hljs shell">git config --system  --unset credential.helper<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#  如果用了第一个命令 还不能解决问题那么 用这个命令：</span></span>git config –global http.emptyAuth true</code></pre>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>Idea</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建Hexo个人博客</title>
    <link href="/2020/02/10/%E7%AC%94%E8%AE%B0/%E5%8D%9A%E5%AE%A2/%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2/"/>
    <url>/2020/02/10/%E7%AC%94%E8%AE%B0/%E5%8D%9A%E5%AE%A2/%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>​    使用hexo搭建个人博客是一个朋友推荐的；因为可以说是完全<strong>免费</strong>，虽然我自己也有服务器，但是还是使用了这个，要问我为什么，就是搭建简单。<strong>ps : 程序员最缺的就是时间不是么</strong>  :smiley:</p><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><ul><li>​    下载 <a href="http://nodejs.org/" target="_blank" rel="noopener">node js</a>  </li><li>​    下载 <a href="http://git-scm.com/" target="_blank" rel="noopener">git</a>    Windows系统的 可以下载<a href="https://npm.taobao.org/mirrors/git-for-windows/" target="_blank" rel="noopener">淘宝镜像</a>比较快</li></ul><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><pre><code class="hljs javascript">npm install -g hexo-cli</code></pre><pre><code class="hljs javascript">hexo -v  <span class="hljs-comment">//  检验是否安装成功</span></code></pre><h3 id="配置博客"><a href="#配置博客" class="headerlink" title="配置博客"></a>配置博客</h3><pre><code class="hljs kotlin"><span class="hljs-comment">//  创建myblog</span>mkdir myblog<span class="hljs-comment">//  进入 博客目录</span>cd myblog <span class="hljs-comment">// 初始化</span>hexo <span class="hljs-keyword">init</span></code></pre><p><img src="D:%5C%E7%AC%94%E8%AE%B0%5C%E5%8D%9A%E5%AE%A2%5C%E7%9B%AE%E5%BD%95.png" srcset="/img/loading.gif" alt=""></p><ul><li>node_modules: 依赖包</li><li>scaffolds：生成文章的一些模板</li><li>source：用来存放你的文章  一般自己写的笔记 丢到   <strong>source/_posts/</strong>  下就好了</li><li>themes：主题      ##  这个自己找（看看自己对页面功能的需求），用的最多的是  <a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">next</a>    我用的是 <a href="https://hexo.fluid-dev.com/" target="_blank" rel="noopener">fluid</a></li><li>** _config.yml: 博客的配置文件**</li></ul><pre><code class="hljs undefined">hexo g  &#x2F;&#x2F;  编译hexo s  &#x2F;&#x2F;  本地启动 默认4000 端口</code></pre><h3 id="把博客配置到GitHub-，这样所有人都能访问的到"><a href="#把博客配置到GitHub-，这样所有人都能访问的到" class="headerlink" title="把博客配置到GitHub ，这样所有人都能访问的到"></a>把博客配置到GitHub ，这样所有人都能访问的到</h3><p> <strong>前提：个人必须要有一个GitHub的账号</strong></p><ol><li><p>去 <a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>  新建一个工程 （要求： 格式必须是 用户名.github.io     比如 name.github.io）</p><p> <img src="D:%5C%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE%5C%E5%8D%9A%E5%AE%A2%5Cimage-20200726154043427.png" srcset="/img/loading.gif" alt=""></p></li></ol><pre><code>工程名必须 跟自己名称一致 加上 .Github.io  **我这里报错 的是因为之前创建了**![image-20200726154608047](D:\笔记截图\博客\image-20200726154608047.png)</code></pre><ol start="2"><li><p>然后去我们创建的博客根目录下  修改 <strong>_config.yml问价</strong>    找到 <code>deploy</code> 这个部分, 修改成</p> <pre><code class="hljs yml"><span class="hljs-attr">deploy:</span>    <span class="hljs-attr">type:</span> <span class="hljs-string">git</span>    <span class="hljs-attr">repo:</span> <span class="hljs-string">git@github.com:xxx/xxx.github.io.git</span>  <span class="hljs-comment">###  你在GitHub创建完工程 生成的地址</span>    <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span></code></pre></li><li><p>部署</p> <pre><code class="hljs javascript">hexo  cl  ##清理hexo  g  ## 编译   ##  每次操作完最好 执行一次，不然会发现你本地运行好好的，远程的内容跟你本地不一致npm install hexo-deployer-git --save   ## 安装git环境  hexo d  ##部署到GitHub   ##  他会让你输入GitHub的账号密码 输入一下就好了</code></pre></li></ol><p>这一步就完成了 然后试试访问一下部署的地址就好了  如：xxx.github.io  我的就是：weimao520.github.io   如果有点闲钱的话 最好自己买一个域名 配置下:smiley:</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>搭建hexo博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Other</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>注册中心之Eureka</title>
    <link href="/2020/02/10/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/1-0-1%20%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E4%B9%8Beureka/"/>
    <url>/2020/02/10/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/1-0-1%20%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E4%B9%8Beureka/</url>
    
    <content type="html"><![CDATA[<h2 id="springboot（Cloud）配置eureka"><a href="#springboot（Cloud）配置eureka" class="headerlink" title="springboot（Cloud）配置eureka"></a>springboot（Cloud）配置eureka</h2><p>​        springCloud  H版之后</p><p>使用最新的的版本（因为容易分清 不容易混淆）</p><h3 id="版本对比"><a href="#版本对比" class="headerlink" title="版本对比"></a>版本对比</h3><p><strong>旧版</strong></p><pre><code class="hljs java">&lt;dependency&gt;     &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;     &lt;artifactId&gt;spring-cloud-starter-eurekar&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p><strong>新版</strong></p><pre><code class="hljs java"> ## 服务端(管理)   eureka 服务端使用 &lt;dependency&gt;      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;      &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;  &lt;/dependency&gt;##  客户端  想把服务自己的服务注册到eureka服务使用这个&lt;dependency&gt;     &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;     &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt;</code></pre><h3 id="YMl-配置"><a href="#YMl-配置" class="headerlink" title="YMl 配置"></a>YMl 配置</h3><p><strong>server端</strong></p><pre><code class="hljs java">eureka:  instance:    hostname: localhost  # eureka服务端实例名称  client:    register-with-eureka: false # false  表示不向注册中心注册自己    fetch-registry: false # false 表示自己就是注册中心，我的职责就是维护实例，并不需要检索服务    service-url:      ##  设置与eureka server交互的地址查询和注册服务都需要依赖这个地址      defaultZone: http:<span class="hljs-comment">//$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka</span></code></pre><p><strong>client</strong> 端</p><pre><code class="hljs java">  ##  eureka  客户端配置eureka:  client:    #  表示是否将自己注册进EurekaServer  默认为true    register-with-eureka: <span class="hljs-keyword">true</span>    ## 是否从EurekaServer 抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡    fetchRegistry: <span class="hljs-keyword">true</span>    service-url:      defaultZone: http:<span class="hljs-comment">//localhost:服务端地址/eureka</span></code></pre><h3 id="启动类配置"><a href="#启动类配置" class="headerlink" title="启动类配置"></a>启动类配置</h3><p><strong>server端</strong>  </p><pre><code class="hljs java"><span class="hljs-comment">//  启动类加上 @EnableEurekaServer</span><span class="hljs-meta">@EnableEurekaServer</span>   <span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(Application<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre><hr><p><strong>client端</strong></p><pre><code class="hljs java"><span class="hljs-comment">//  启动类加上 @EnableEurekaClient</span><span class="hljs-meta">@EnableEurekaClient</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(Application<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre><p>// 注意 启动时候优先启动 server端  因为  服务端不启动  客户端 注册不进去 </p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>微服务</category>
      
      <category>注册中心</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Eureka</tag>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>注册中心之Eureka集群搭建</title>
    <link href="/2020/02/10/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/1-0-1%20%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E4%B9%8Beureka%20%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
    <url>/2020/02/10/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/1-0-1%20%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E4%B9%8Beureka%20%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h3 id="eureka集群搭建"><a href="#eureka集群搭建" class="headerlink" title="eureka集群搭建"></a>eureka集群搭建</h3><p><strong>搭建这个很简单:smile_cat:</strong></p><p>就是两个<strong>服务互相注册，互相守望</strong></p><p>话不多说上代码：</p><pre><code class="hljs java">## 两个都是server 端 pox 都是这个        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;        &lt;/dependency&gt;</code></pre><p><strong>Yml配置</strong></p><pre><code class="hljs java">##  两个配置 其实都差不多 互相监听## server 配置##  7001配置eureka:  instance:    hostname: eureka7001.com  # eureka服务端实例名称  client:    register-with-eureka: false # false  表示不向注册中心注册自己    fetch-registry: false # false 表示自己就是注册中心，我的职责就是维护实例，并不需要检索服务    service-url:      ##  设置与eureka server交互的地址查询和注册服务都需要依赖这个地址      defaultZone: http:<span class="hljs-comment">//eureka7002.com:7002/eureka</span>##  7002配置eureka:  instance:    hostname: eureka7002.com  client:    register-with-eureka: false # false  表示不向注册中心注册自己    fetch-registry: false # false 表示自己就是注册中心，我的职责就是维护实例，并不需要检索服务    service-url:      ##  设置与eureka server交互的地址查询和注册服务都需要依赖这个地址      defaultZone: http:<span class="hljs-comment">//eureka7001.com:7001/eureka</span>###  客户端配置eureka:  client:    #  表示是否将自己注册进EurekaServer  默认为true    register-with-eureka: <span class="hljs-keyword">true</span>    ## 是否从EurekaServer 抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡    fetchRegistry: <span class="hljs-keyword">true</span>    service-url:#     defaultZone: http://localhost:7001/eureka  # 单机版      defaultZone: http:<span class="hljs-comment">//eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka </span>instance-id: payment8001 #  实例名称（微服名称）    prefer-ip-address: true  # 微服务显示的是IP地址而不是 如：localhost  地址    # eureka服务端在收到最后一次心跳后等待时间上线，单位微秒（默认 90秒），超时将剔除服务    lease-expiration-duration-in-seconds: <span class="hljs-number">2</span>#   eureka 客户端向客户端向服务端发送心跳的时间间隔，单位为秒（默认30秒）    lease-renewal-interval-in-seconds:  <span class="hljs-number">1</span>eureka:  client:    #  表示是否将自己注册进EurekaServer  默认为true    register-with-eureka: <span class="hljs-keyword">true</span>    ## 是否从EurekaServer 抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡    fetchRegistry: <span class="hljs-keyword">true</span>    service-url:#     defaultZone: http://localhost:7001/eureka  # 单机版      defaultZone: http:<span class="hljs-comment">//eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka </span>instance-id: payment8002 #  实例名称    prefer-ip-address: true  # 微服务访问路劲显示的是IP地址而不是 如：localhost  地址</code></pre><p>//  只测试一个客户端  //  另外代码一样</p><h3 id="测试获取eureka信息-slightly-smiling-face"><a href="#测试获取eureka信息-slightly-smiling-face" class="headerlink" title="测试获取eureka信息 :slightly_smiling_face:"></a>测试获取eureka信息 :slightly_smiling_face:</h3><pre><code class="hljs java"><span class="hljs-comment">//  去启动类中加入 @EnableDiscoveryClient   我这边不加也没事</span><span class="hljs-comment">//  去controller 层 </span><span class="hljs-meta">@RestController</span><span class="hljs-meta">@Slf</span>4j<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestController</span> </span>&#123;        <span class="hljs-meta">@autowired</span>     <span class="hljs-keyword">private</span> DiscoveryClient discoveryClient;             <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"discovery"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">discovery</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//        获取服务列表对应 注册中心上有几个微服务</span>        List&lt;String&gt; services = <span class="hljs-keyword">this</span>.discoveryClient.getServices();        <span class="hljs-keyword">for</span> (String service : services) &#123;            log.info(<span class="hljs-string">"*********server:&#123;&#125;"</span>, service);        &#125;<span class="hljs-comment">//        获取该微服务下的全部实例</span>        List&lt;ServiceInstance&gt; instances = <span class="hljs-keyword">this</span>.discoveryClient.getInstances(<span class="hljs-string">"CLOUD-PAYMENT-SERVICE"</span>);        <span class="hljs-keyword">for</span> (ServiceInstance instance : instances) &#123;            log.info(<span class="hljs-string">"服务id:&#123;&#125;-主机名称:&#123;&#125;-主机端口号&#123;&#125;-URI地址&#123;&#125;"</span>                ,instance.getServiceId(),instance.getHost(),instance.getPort(),instance.getUri());        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.discoveryClient;    &#125;        &#125;</code></pre><h3 id="Eureka-自我保护-机制（属于Cap中的ap）-默认开启"><a href="#Eureka-自我保护-机制（属于Cap中的ap）-默认开启" class="headerlink" title="Eureka  自我保护 机制（属于Cap中的ap） 默认开启"></a>Eureka  自我保护 机制（属于Cap中的ap） 默认开启</h3><p>某时某刻一个微服务 不可用了（如：网咯延迟） ，eureka不会立即清理，依旧会对该服务的信息进行保存</p><pre><code class="hljs java"><span class="hljs-comment">// 服务端</span>eureka:server:enable-self-preservation: <span class="hljs-keyword">false</span>  <span class="hljs-comment">//  关闭自我保护，保证服务不可用就立即剔除</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>微服务</category>
      
      <category>注册中心</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务</tag>
      
      <tag>Eureka集群</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
